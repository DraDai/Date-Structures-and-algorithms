#include <stdio.h>
#include <math.h>
#include <string.h>
//静态链表的遍历
void text();
struct LintNode
{
	int date;
	struct LintNode *next;
};

void text()
{
	struct LintNode node1 = {10, NULL};
	struct LintNode node2 = {20, NULL};
	struct LintNode node3 = {30, NULL};
	struct LintNode node4 = {40, NULL};
	struct LintNode node5 = {50, NULL};
	struct LintNode node6 = {60, NULL};

	node1.next = &node2;
	node2.next = &node3;
	node3.next = &node4;
	node4.next = &node5;
	node5.next = &node6;

	struct LintNode *p_current = &node1;
	while (p_current != NULL)
	{
		printf("%d ", p_current -> date);
		p_current = p_current -> next;
	}
}

int main()
{
	text();

	return 0;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//初始化动态链表, 并且遍历链表
struct LinkNode *Init_LinkList();
void Foreach_LinkList(struct LinkNode *header);

struct LinkNode
{
	int date;
	struct LinkNode *next;
};
//初始化链表
struct LinkNode *Init_LinkList()
{
	//创建头节点并分配空间
	struct LinkNode *header = malloc(sizeof(struct LinkNode));
	header -> date = -1;
	header -> next = NULL;
	//创建尾部指针
	struct LinkNode *pRear = header;
	//创建新节点并向其输入数据
	int val = 1;
	while (val != -1)
	{
		printf("请输入新的数据：\n");
		scanf("%d", &val);
		if (val == -1)
			break;
		//创建节点
		struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
		new_node -> date = val;
		new_node -> next = NULL;
		//将新节点插入前面
		pRear -> next = new_node;
		//移动尾部指针
		pRear = new_node;
	}
	//返回头节点地址
	return header;
}
//遍历链表
void Foreach_LinkList(struct LinkNode *header)
{
	if (header == NULL)
		return;
	//辅助指针变量
	struct LinkNode *pCurrent = header -> next;
	while (pCurrent != NULL)
	{
		printf("%d ", pCurrent -> date);
		pCurrent = pCurrent -> next;
	}
}

int main()
{
	//初始化链表
	struct LinkNode *header = Init_LinkList();
	//遍历链表
	Foreach_LinkList(header);
	return 0;
}



//插入新节点
void Insert_val(struct LinkNode *header, int old_val, int new_val)
{
    if (header == NULL)
        return;
    //构造两个指针变量，两指针变量相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到old val，并让pCurrent指向old val
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == old_val)
            break;
        
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    //如果pCurrent为NULL， 那么不插入
    if (pCurrent == NULL)
        return;
    //创建新节点
    struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
    new_node -> date = new_val;
    new_node -> next = NULL;
    //将新节点放在old node前一格
    pPrev -> next = new_node;
    new_node -> next = pCurrent;
}


//清空链表
void Clear_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;

    //创建辅助指针变量，使之指向头节点下一个节点
    struct LinkNode *pCurrent = header -> next;
    //逐个清空节点
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放当前节点内存
        free(pCurrent);
        //pCurrent指向下一个节点
        pCurrent = pNext;
    }
    //让头节点指向空
    header -> next = NULL;
}
	



//删除节点
void Delete_val(struct LinkNode *header, int del_val)
{
    if (header == NULL)
        return;
    //创建两个辅助指针变量使之相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到要删除的节点
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == del_val)
            break;
        //移动两个指针
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    if (pCurrent == NULL)
        return;
    //删除节点
    pPrev -> next = pCurrent -> next;
    free(pCurrent);
    pCurrent = NULL;
}

//销毁链表
void Destroy_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;
    //创建辅助指针变量
    struct LinkNode *pCurrent = header;
    //依次释放每个节点的内存
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放该节点内存
        free(pCurrent);
        //指向下一节点
        pCurrent = pNext;
    }
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//初始化动态链表
struct LinkNode *Init_LinkList();
//遍历链表
void Foreach_LinkList(struct LinkNode *header);
//插入节点
void Insert_val(struct LinkNode *header, int old_val, int nem_val);
//清空链表
void Clear_LinkList(struct LinkNode *header);
//删除节点
void Delete_val(struct LinkNode *header, int del_val);
//销毁链表
void Destroy_LinkList(struct LinkNode *header);

struct LinkNode
{
	int date;
	struct LinkNode *next;
};

//初始化链表
struct LinkNode *Init_LinkList()
{
	//创建头节点并分配空间
	struct LinkNode *header = malloc(sizeof(struct LinkNode));
	header -> date = -1;
	header -> next = NULL;
	//创建尾部指针
	struct LinkNode *pRear = header;
	//创建新节点并向其输入数据
	int val = 1;
	while (val != -1)
	{
		printf("请输入新的数据：\n");
		scanf("%d", &val);
		if (val == -1)
			break;
		//创建节点
		struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
		new_node -> date = val;
		new_node -> next = NULL;
		//将新节点插入前面
		pRear -> next = new_node;
		//移动尾部指针
		pRear = new_node;
	}
	//返回头节点地址
	return header;
}

//遍历链表
void Foreach_LinkList(struct LinkNode *header)
{
	if (header == NULL)
		return;
	//辅助指针变量
	struct LinkNode *pCurrent = header -> next;
	while (pCurrent != NULL)
	{
		printf("%d ", pCurrent -> date);
		pCurrent = pCurrent -> next;
	}
}

//插入新节点
void Insert_val(struct LinkNode *header, int old_val, int new_val)
{
    if (header == NULL)
        return;
    //构造两个指针变量，两指针变量相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到old val，并让pCurrent指向old val
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == old_val)
            break;
        
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    //如果pCurrent为NULL， 那么不插入
    if (pCurrent == NULL)
        return;
    //创建新节点
    struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
    new_node -> date = new_val;
    new_node -> next = NULL;
    //将新节点放在old node前一格
    pPrev -> next = new_node;
    new_node -> next = pCurrent;
}

//清空链表
void Clear_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;

    //创建辅助指针变量，使之指向头节点下一个节点
    struct LinkNode *pCurrent = header -> next;
    //逐个清空节点
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放当前节点内存
        free(pCurrent);
        //pCurrent指向下一个节点
        pCurrent = pNext;
    }
    //让头节点指向空
    header -> next = NULL;
}

//删除节点
void Delete_val(struct LinkNode *header, int del_val)
{
    if (header == NULL)
        return;
    //创建两个辅助指针变量使之相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到要删除的节点
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == del_val)
            break;
        //移动两个指针
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    if (pCurrent == NULL)
        return;
    //删除节点
    pPrev -> next = pCurrent -> next;
    free(pCurrent);
    pCurrent = NULL;
}

//销毁链表
void Destroy_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;
    //创建辅助指针变量
    struct LinkNode *pCurrent = header;
    //依次释放每个节点的内存
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放该节点内存
        free(pCurrent);
        //指向下一节点
        pCurrent = pNext;
    }
}
int main()
{
	//初始化链表
	struct LinkNode *header = Init_LinkList();
	//遍历链表
	Foreach_LinkList(header);
    //插入新节点
    printf("输入新的数据：\n");
    int new_val;
    scanf("%d", &new_val);
    Insert_val(header, 600, new_val);
    printf("\n-------------------\n");
    //再次遍历链表
    Foreach_LinkList(header);
    //删除某个节点
    printf("\n输入你要删除的数据：\n");
    int del_val;
    scanf("%d", &del_val);
    Delete_val(header, del_val);
    //再次遍历链表
    Foreach_LinkList(header);
    //清空链表
    printf("\n是否清空链表？请输入yes或no：\n");
    char str[5];
    getchar();
    gets(str);
    if (strcmp(str, "yes") == 0)
    {    Clear_LinkList(header);
        //再次遍历链表检查是否清空链表
        Foreach_LinkList(header);
    }
    else if(strcmp(str, "no") == 0)
    {
        Foreach_LinkList(header);
    }
	return 0;
}

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define MAX_SIZE 30
//创建线性表结构类型
struct LNode
{
    //创建数组
    int Data[MAX_SIZE];
    //记录最后数据下标
    int Last;
};
//定义结构指针
typedef struct LNode *List;

//初始化线性表
List MarkEmpty();
//查找数据
int Find(int x, List PtrL);
//插入数据
void Insert(int x, int i, List PtrL);
//删除元素
void Delete(int i, List PtrL);

//初始化线性表
List MarkEmpty()
{
    //创建线性表
    List PtrL;
    //分配空间
    PtrL = (List)malloc(sizeof(struct LNode));
    PtrL -> Last = -1;
    return PtrL;
}

//查找数据
int Find(int x, List PtrL)
{
    int i = 0;
    //逐个查找数据
    while (i <= PtrL -> Last && PtrL -> Data[i] != x)
    {
        i++;
    }
    //如果没找到，返回-1, 否则返回i
    if (i > PtrL -> Last)
        return -1;
    else    
        return i + 1;
}

//插入数据
void Insert(int x, int i, List PtrL)
{
    int j;
    //判断线性表是否装满
    if (PtrL -> Last == MAX_SIZE - 1)
    {
        printf("线性表已满\n");
        return;
    }
    //检查插入位置的合法性
    if (i < 1 || i > PtrL->Last + 2)
    {
        printf("位置不合法！");
        return;
    }
    for (j = PtrL -> Last; j >= i - 1; j--)
    {
        PtrL -> Data[j + 1] = PtrL -> Data[j];
    }
    //插入新元素
    PtrL -> Data[i - 1] = x;
    //Last仍指向最后元素
    PtrL -> Last++;
}

//删除元素
void Delete(int i, List PtrL)
{
    int j;
    //检查空表及删除位置
    if (i < 1 || i > PtrL->Last + 1)
    {
        printf("不存在第%d个元素", i);
        return;
    }
    //将每个删除位置后的元素向前移一个
    for (j = i; j <= PtrL->Last; j++)
    {
        PtrL->Data[j - 1] = PtrL->Data[j];
    }
    //让Last指向最后一个数据
    PtrL->Last--;
}

int main()
{
    struct LNode *L;
    L = MarkEmpty();
    L->Last = 20;
    int i;

    printf("请输入数组元素：\n");
    for (i = 0; i < L->Last; i++)
    {
        scanf("%d", &L->Data[i]);
    }

    for (i = 0; i < L->Last; i++)
    {
        printf("%d ", L->Data[i]);
    }

    //查找元素位置
    int find;
    printf("\n输入待查找元素：\n");
    scanf("%d", &find);
    find = Find(find, L);
    printf("%d\n", find);

    int X;
    printf("请输入插入元素和插入位置：\n");
    scanf("%d%d", &X, &i);
    Insert(X, i, L);

    for (i = 0; i < L->Last; i++)
    {
        printf("%d ", L->Data[i]);
    }

    printf("\n请输入删除位置：\n");
    scanf("%d", &i);
    Delete(i, L);

    for (i = 0; i < L->Last; i++)
    {
        printf("%d ", L->Data[i]);
    }
    return 0;
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//堆栈的实现
//创建顺序类型堆栈

//创建顺序类型堆栈数据结构
struct SNode
{
    //创建存储数据的数组
    int *date;
    //创建栈顶指针
    int top;
    //堆栈最大容量
    int max_size;
};
typedef struct SNode *Stack;

//初始化顺序栈
Stack CreateStack(int max_size)
{
    //给线性表分配内存
    Stack S = (Stack)malloc(sizeof(struct SNode));
    //给数组分配内存
    S->date = (int *)malloc(max_size * sizeof(int));
    S->max_size = max_size;
    //将top调到-1
    S->top = -1;
    return S;
}

//入栈操作Push
void Push(int item, Stack PtrL)
{
    //判断堆栈满没满，满则退出，没满则入栈
    if (PtrL->top == PtrL->max_size - 1)
    {
        printf("堆栈已满！\n");
        return;
    }
    else
    {
        PtrL->top++;
        PtrL->date[PtrL->top] = item;
        return;
    }
}

//出栈操作Pop
int Pop(Stack PtrL)
{
    //判断堆栈是否为空
    if (PtrL->top == -1)
    {
        printf("堆栈为空！\n");
        return NULL;
    }
    else
    {
        int item;
        item = PtrL->date[PtrL->top];
        PtrL->top--;
        return item;
    }
}

int main()
{
    int max_size, i, s;
    printf("输入栈的长度：\n");
    scanf("%d", &max_size);
    struct SNode *stack1 = CreateStack(max_size);
    for (i = 1; i <= max_size; i++)
    {
        s = i * 2 + 1;
        Push(s, stack1);
    }
    int item;
    item = Pop(stack1);
    while (item != NULL)
    {
        printf("%d ", item);
        item = Pop(stack1);
    }
    return 0;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//堆栈的实现
//创建顺序类型堆栈

//创建二项顺序类型堆栈数据结构
struct SNode
{
    //创立储存元素的数组
    int *data;
    //创建两个栈顶指针，一个在表前，一个在表后
    int top1;
    int top2;
    //堆栈长度
    int max_size;
};
typedef struct SNode *Stack;

//创建双向堆栈
Stack CreateStackTwo(int max_size)
{
    //给堆栈分配内存
    Stack S = (Stack)malloc(sizeof(struct SNode));
    //给数组分配内存
    S->data = (int *)malloc(max_size * sizeof(int));
    S->max_size = max_size;
    //将top1调到-1
    S->top1 = -1;
    //将top2调到max_size
    S->top2 = max_size;
    return S;
}

//双向堆栈入栈操作
void PushTwo(Stack PtrL, int item, int Tag)
{
    //判断堆栈是否堆满
    if (PtrL->top1 + 1 == PtrL->top2)
    {
        printf("堆栈已满！\n");
        return;
    }
    else
    {   //Tag作为区分两个堆栈的标志，取值为1和2
        if (Tag == 1)
        {
            PtrL->top1++;
            PtrL->data[PtrL->top1] = item;
        }
        else
        {
            PtrL->top2--;
            PtrL->data[PtrL->top2] = item;
        }
    }
}

//双向堆栈出栈操作
int PopTwo(Stack PtrL, int Tag)
{
    int item;
   //Tag作为区分两个堆栈的标志，取值为1和2
   if (Tag == 1)
   {
        //判断第一个堆栈是否为空
        if (PtrL->top1 == -1)
        {
            printf("堆栈1已空！\n");
            return NULL;
        }
        else
        {
            item = PtrL->data[PtrL->top1];
            PtrL->top1--;
            return item;
        }
   } 
   else
   {
        //判断第二个堆栈是否为空
        if (PtrL->top2 == PtrL->max_size)
        {
            printf("堆栈2已空！\n");
            return NULL;
        }
        else
        {
            item = PtrL->data[PtrL->top2];
            PtrL->top2++;
            return item;
        }
   }
}

int main()
{
    int max_size, i, s1, s2;
    printf("输入栈的长度：\n");
    scanf("%d", &max_size);
    struct SNode *stack1 = CreateStackTwo(max_size);
    for (i = 1; i <= max_size / 2; i++)
    {
        s1 = i * 2 + 1;
        PushTwo(stack1, s1, 1);
    }
    for (i = max_size / 2 + 1; i <= max_size; i++)
    {
        s2 = i + 2;
        PushTwo(stack1, s2, 2);
    }

    int item;
    item = PopTwo(stack1, 1);
    while (item != NULL)
    {
        printf("%d ", item);
        item = PopTwo(stack1, 1);
    }
    printf("\n");
    item = PopTwo(stack1, 2);
    while (item != NULL)
    {
        printf("%d ", item);
        item = PopTwo(stack1, 2);
    }
    return 0;
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//堆栈的链式储存实现
//创建链栈的数据结构
struct SNode
{
    int data;
    struct SNode *next;
};
typedef struct SNode *Stack;

//创建堆栈头节点
Stack CreateStack()
{
    Stack header;
    //给头节点分配内存
    header = (Stack)malloc(sizeof(struct SNode));
    header->data = -1;
    header->next = NULL;
    return header;
}

//将元素压入栈顶
void Push(Stack S, int item)
{
    //创建辅助指针
    Stack pCurrent;
    //创建节点
    pCurrent = (Stack)malloc(sizeof(struct SNode));
    pCurrent->data = item;
    //将头节点后的数据放在新节点后面
    pCurrent->next = S->next;
    S->next = pCurrent;
}

//删除并返回栈顶元素
int Pop(Stack S)
{
    //创建辅助堆栈指针1
    Stack pCurrent;
    pCurrent = S->next;
    //判断堆栈是否为空
    if (pCurrent->data == -1)
    {
        printf("堆栈已空！\n");
        return NULL;
    }
    else
    {
        int item;
        //删除并返回数据
        
        S->next = pCurrent->next;
        item = pCurrent->data;
        //释放指向节点内存
        free(pCurrent);
        //返回数据
        return item;
    }
}

int main()
{
    Stack PtrL;
    PtrL = CreateStack();
    int item, i;
    for (i = 1; i <= 10; i++)
    {
        //输入数据，压入栈中
        printf("请输入数据：\n");
        scanf("%d", &item);
        Push(PtrL, item);
    }
    item = Pop(PtrL);
    while (item != NULL)
    {
        printf("%d ", item);
        item = Pop(PtrL);
    }
    return 0;
}




#include <stdio.h>
#include <math.h>
#include <string.h>

//至诚图书管理系统
int main()
{
    printf("-----------------欢迎来到至诚图书库！-----------------\n");
    int s_number = 1;
    int Allow = 0;
    //创建用户名数组和密码数组
    char username[20][20];
    char password[20][15];
    //创建图书库
    char books[7][50] = {"十二国记", "青春猪头少年不会梦到兔女郎学姐", "浪客剑心", "白色相簿2", "孤独摇滚", "寒蝉鸣泣之时", "命运石之门"};
    //我的图书库
    char my_books[7][50] = {0};
    int i = 0, j = 0, k = 0;
    while (s_number != 0)
    {
        printf("请选择您的需求：（输入数字即可：）\n");
        printf("1.注册\n");
        printf("2.登录\n");
        printf("3.借书\n");
        printf("4.还书\n");
        printf("0.退出程序\n");
        //输入序号
        scanf("%d", &s_number);
        //注册程序
        while (s_number == 1)
        {
            printf("请输入您的用户名：");
            scanf("%s", username[i]);
            printf("请输入您的密码：");
            scanf("%s", password[i]);
            if(username[i][0] == '\0' || password[i][0] == '\0')
            {
                printf("注册失败！请重新注册！\n");
            }
            else if (i == 20)
            {
                printf("账号已满，无法继续注册\n");
                s_number = -1;
            }
            else
            {
                printf("注册成功！\n\n\n");
                s_number = -1;
                i++;
            }
        }
        //登录程序
        while (s_number == 2)
        {
            int flag1 = 0, flag2 = 0;
            char p_username[20];
            char p_password[15];
            char yes_no[5] = {0};
            printf("请输入您的用户名：");
            scanf("%s", p_username);
            printf("请输入您的密码：");
            scanf("%s", p_password);
            //从用户名数组和密码数组中查找此账号
            for (j = 0; j <= i; j++)
            {
                if (strcmp(username[j], p_username) == 0)
                    flag1 = 1;
                if (strcmp(password[j], p_password) == 0)
                    flag2 = 1;
                if (flag1 == 1 && flag2 == 1)
                {
                    printf("登录成功！\n\n\n");
                    Allow = 1;
                    s_number = -1;
                    break;
                }
            }
            if (flag1 != 1 || flag2 != 1)
            {
                printf("登录失败！\n");
                printf("您是否要退出登录，还是重新登录（输入yes或no)：");
                scanf("%s", yes_no);
                if (strcmp(yes_no, "yes") == 0)
                {
                    s_number = -1;
                    break;
                }
            }
        }
        //借书程序
        while (s_number == 3)
        {
            //判断是否登录
            if (Allow != 1)
            {
                printf("请登录后再使用！\n");
                s_number = -1;
                break;
            }
            else
            {
            	char yes_no[5] = {0};
                printf("本馆目前库存如下：\n");
                //打印书单
                for (k = 0; k < 7; k++)
                {
                    if (books[k][0] == '\0')
                        break;
                    printf("%d.%s\n", k + 1, books[k]);
                }
                printf("\n\n\n");
                //借书
                do
                {
                    if (books[0][0] == '\0')
                    {
                        printf("图书馆已空，无法借书！\n");
                        s_number = -1;
                        break;
                    }
                    printf("请输入您要借的书的序号：");
                    int book_number;
                    
                    scanf("%d", &book_number);
                    //判断借书是否成功
                    if (books[book_number - 1][0] == '\0')
                    {
                        printf("暂无此书！\n");
                        printf("您是否要继续借书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                    else
                    {
                        //将图书馆书籍放入我的借书库中
                        for (k = 0; k < 7; k++)
                        {
                            if (my_books[k][0] == '\0')
                            {
                                strcpy(my_books[k], books[book_number - 1]);
                                break;
                            }
                        }
                        printf("借书成功！\n\n\n");
                        //整理图书馆
                        if (books[book_number][0] == '\0' || book_number == 7)
                        {
                        	books[book_number - 1][0] = '\0';
						}
						else
						{
	                        while (books[book_number][0] != '\0')
	                        {
	                            strcpy(books[book_number - 1], books[book_number]);
	                            books[book_number][0] = '\0';
	                            book_number++;
	                        }
	                    }
                        //写出现有书单
                        printf("现在的库存有：\n");
                        for (k = 0; k < 7; k++)
                        {
                            if (books[k][0] == '\0')
                                break;
                            printf("%d.%s\n", k + 1, books[k]);
                        }
                        printf("\n\n\n");
                        //是否继续借书
                        printf("您是否要继续借书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                }while (strcmp(yes_no, "yes") == 0);
                if (strcmp(yes_no, "no") == 0)
                    s_number = -1;
            }
        }
        //还书程序
        while (s_number == 4)
        {
            //判断是否登录
            if (Allow != 1)
            {
                printf("请登录后再使用！\n");
                s_number = -1;
                break;
            }
            else
            {
                char yes_no[5] = {0};
                printf("您已借的图书有：\n");
                //打印书单
                for (k = 0; k < 7; k++)
                {
                    if (my_books[k][0] == '\0')
                        break;
                    printf("%d.%s\n", k + 1, my_books[k]);
                }
                printf("\n\n\n");
                //还书
                do
                {
                    if (my_books[0][0] == '\0')
                    {
                        printf("暂无借书，无法还书！\n");
                        s_number = -1;
                        break;
                    }
                    printf("请输入您要还的书的序号：");
                    int book_number;
                    
                    scanf("%d", &book_number);
                    //判断还书是否成功
                    if (my_books[book_number - 1][0] == '\0')
                    {
                        printf("暂无此书！\n");
                        printf("您是否要继续还书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                    else
                    {
                        //将我借的书籍放入图书馆中
                        for (k = 0; k < 7; k++)
                        {
                            if (books[k][0] == '\0')
                            {
                                strcpy(books[k], my_books[book_number - 1]);
                                break;
                            }
                        }
                        printf("还书成功！\n\n\n");
                        //整理我的结束库
                        if (my_books[book_number][0] == '\0' || book_number == 7)
                        {
                        	my_books[book_number - 1][0] = '\0';
						}
						else
						{
	                        while (my_books[book_number][0] != '\0')
	                        {
	                            strcpy(my_books[book_number - 1], my_books[book_number]);
	                            my_books[book_number][0] = '\0';
	                            book_number++;
	                        }
	                    }
                        //写出现有书单
                        printf("现在的借书有：\n");
                        for (k = 0; k < 7; k++)
                        {
                            if (my_books[k][0] == '\0')
                                break;
                            printf("%d.%s\n", k + 1, my_books[k]);
                        }
                        printf("\n\n\n");
                        //是否继续借书
                        printf("您是否要继续还书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                }while (strcmp(yes_no, "yes") == 0);
                if (strcmp(yes_no, "no") == 0)
                    s_number = -1;

            }
        }
    }
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//循环队列的创建与插入的删除

//创建顺序结构数据类型
struct SNode
{
    int data[10];
    //创建头元素位置变量
    int front;
    //创建尾元素变量
    int rear;
};
typedef struct SNode *QNode;

//入队列函数
void AddQ(QNode PtrQ, int item)
{
    //判断队列满没满
    if ((PtrQ->rear + 1) % 10 == PtrQ->front)
    {
        printf("队列已满！\n");
        return;
    }
    //将新增元素放在队尾，并将队尾变量加一
    PtrQ->rear = (PtrQ->rear + 1) % 10;
    PtrQ->data[PtrQ->rear] = item;
}

//出队列函数
int DeleteQ(QNode PtrQ)
{
    //判断队列空没空
    if (PtrQ->front == PtrQ->rear)
    {
        printf("队列已空！\n");
        return 1;
    }
    else
    {
        //将队首元素返回，并将队首变量加一
        PtrQ->front = (PtrQ->front + 1) % 10; 
        int item;
        item = PtrQ->data[PtrQ->front];
        return item;
    }    
}

int main()
{
    QNode p_arr = (QNode)malloc(sizeof(struct SNode));
    p_arr->front = 0;
    p_arr->rear = 0;
    int i, item;
    for (i = 1; i <= 9; i++)
    {
        scanf("%d", &item);
        AddQ(p_arr, item);
    }
    for (i = 1; i <= 9; i++)
    {
        item = DeleteQ(p_arr);
        printf("%d ", item);
    }
    return 0;
} 




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//队列的链式存储实现

//创建基本数据类型
struct Node
{
    int data;
    struct Node *next;
};
//创建队列指针数据类型
struct QNode
{
    //创建队尾指针
    struct Node *rear;
    //创建队首指针
    struct Node *front;
};
typedef struct QNode *Queue;

//出队函数
int DeleteQ(Queue PtrQ)
{
    //创建队首指针和队首数据域变量
    struct Node *front_cell;
    int front_item;
    //判断队列是否为空
    if (PtrQ->front == NULL)
    {
        printf("队列已空！\n");
        return 0;
    }
    //让队首指针指向要删除节点
    front_cell = PtrQ->front;
    //如果队列只有一个元素，删除后让队列为空,否则头节点指向下一个节点
    if (PtrQ->front == PtrQ->rear)
        PtrQ->front = PtrQ->rear = NULL;
    else
        PtrQ->front = PtrQ->front->next;
    //将要删除元素赋给队首数据域变量
    front_item = front_cell->data;
    //释放待删除节点内存
    free(front_cell);
    //返回数据域变量
    return front_item;
}

//入队函数
void AddQ(Queue PtrQ, int item)
{
    //创建节点辅助指针
    struct Node *pCurrent;
    //为其分配内存，并将数据存入数据域
    pCurrent = malloc(sizeof(struct Node));
    pCurrent->data = item;
    pCurrent->next = NULL;
    //假如队列为空
    if (PtrQ->front == NULL)
    {
        PtrQ->front = pCurrent;
        PtrQ->rear = pCurrent;
        return;
    }
    else
    {
        //否则将新节点连接在队尾，并将队尾指针指向新节点
        PtrQ->rear->next = pCurrent;
        PtrQ->rear = pCurrent;
        return;
    }
}
int main()
{
    Queue PtrQ;
    PtrQ = malloc(sizeof(struct QNode));
    PtrQ->front = NULL;
    PtrQ->rear = NULL;
    int i, item;
    for (i = 1; i <= 10; i++)
    {
        scanf("%d", &item);
        AddQ(PtrQ, item);
    }
    item = DeleteQ(PtrQ);
    while (item != 0)
    {
        printf("%d ", item);
        item = DeleteQ(PtrQ);
    }
    return 0;
} 





#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//比较函数
int Compare(int a, int b);
//置尾函数
void Attach(int a, int b, Polynomial *p);

//多项式加法运算

//创建多项式数据类型
struct PolyNode
{
    //系数
    int coef;
    //指数
    int expon;
    //指向下一个节点的指针
    struct PolyNode *next;
};
typedef struct PolyNode *Polynomial;
Polynomial p1, p2;

//置尾函数
void Attach(int a, int b, Polynomial p)
{
    //创建多项式节点
    Polynomial P;
    //为新节点赋予内存和赋值
    P = (Polynomial)malloc(sizeof(struct PolyNode));
    P->coef = a;
    P->expon = b;
    P->next = NULL;
    p->next = P;
    p = P;
}
//多项式相加函数
Polynomial PolyAdd(Polynomial p1, Polynomial p2)
{
    //创建和多项式链表头节点和尾节点
    Polynomial front, rear, temp;
    //定义系数和变量
    int sum;
    //给头节点赋予内存
    front = (Polynomial)malloc(sizeof(struct PolyNode));
    rear = front;
    //当p1和p2都没加完时
    while (p1 != NULL && p2 != NULL)
    {
        //对p1指向节点的指数和p2的相比较
        switch(Compare(p1->expon, p2->expon))   //Compare函数需自己实现
        //当p1指向节点的指数大于p2时
        case 1:
            //将p1指向的节点放到和多项式链表表尾
            Attach(p1->coef, p1->expon, rear);
            //将p1向后移
            p1 = p1->next;
            break;
        //当p1指向节点的指数小于p2时
        case -1:
            //将p2指向的节点放到和多项式链表表尾
            Attach(p2->coef, p2->expon, rear);
            //将p2向后移
            p2 = p2->next;
            break;
        //当p1指向节点的指数等于于p2时
        case 0:
            //将p1和p2所指向节点的系数相加
            sum = p1->coef + p2->coef;
            //如果和不为0
            if (sum != 0)
                Attach(sum, p1->expon, rear);
            //将p1和p2向后移
            p1 = p1->next;
            p2 = p2->next;
            break;
    }
    //如果某个多项式加完了，那么就将另一个多项式剩余的项放在和多项式后面
    if (p1 == NULL)
    {
        Attach(p2->coef, p2->expon, rear);
        p2 = p2->next;
    }
    if (p2 = NULL)
    {
        Attach(p1->coef, p1->expon, rear);
        p1 = p1->next;
    }
    //将和多项式尾部节点指向空
    rear->next = NULL;
    //销毁头节点，并返回和多项式表头
    temp = front;
    front = front->next;
    free(temp);
    return front;
}


#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10
//静态查找

//定义数组数据类型
struct Node
{
    int arr[Max_size];
    int length;
};
typedef struct Node *List;
List PtrQ;

//顺序查找函数
int Sqt_srch(List PtrQ, int K)
{
    int i;
    //建立哨兵，碰到哨兵退出循环
    PtrQ->arr[0] = K;
    //从末尾向前查找
    for (i = PtrQ->length; PtrQ->arr[i] != K; i--)
        return i;
    if (i == 0)
        return 0;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10
//二分查找法

//定义数组数据类型
struct Node
{
    int arr[Max_size];
    int length;
};
typedef struct Node *List;
List PtrQ;

//二分查找函数
//数组内元素一定是从小到大排序好的
int BinarySearch(List PtrQ, int K)
{
    //定义左变量，右变量，中间变量
    int left, right, mid;
    left = 1;
    right = PtrQ->length;
    //当右变量下标大于左变量的时
    while (left <= right)
    {
        //计算中间变量下标
        mid = (left + right) / 2;
        //如果K大于中间变量
        if (K > PtrQ->arr[mid])
            left = mid + 1;
        //如果K小于中间变量
        else if (K < PtrQ->arr[mid])
            right = mid - 1;
        //如果K等于中间变量
        else    
            return mid;
    }
    return -1;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10

//二叉树的链表储存结构
struct TreeNode
{
    int data;
    //定义指向左节点和右节点的指针
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;







#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10

//先序中序后序递归遍历二叉树
//二叉树的链表储存结构
struct TreeNode
{
    int data;
    //定义指向左节点和右节点的指针
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//先序递归遍历二叉树
void PreOrderTraversal(BinTree BT)
{
    if (BT != NULL)
    {
        printf("%d ", BT->data);
        PreOrderTraversal(BT->left);
        PreOrderTraversal(BT->right);
    }
}

//中序遍历二叉树
void InOrderTraversal(BinTree BT)
{
    if (BT != NULL)
    {
        InOrderTraversal(BT->left);
        printf("%d ", BT->data);
        InOrderTraversal(BT->right);
    }
}

//后序遍历二叉树
void PostOderTraversal(BinTree BT)
{
    if (BT != NULL)
    {
        PostOderTraversal(BT->left);
        PostOderTraversal(BT->right);
        printf("%d ", BT->data); 
    }
}





#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10

//利用堆栈先序中序非递归遍历二叉树

//二叉树的链表储存结构
struct TreeNode
{
    int data;
    //定义指向左节点和右节点的指针
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//创建堆栈数据类型
struct SNode
{
    int data;
    struct SNode *next;
};
typedef struct SNode *Stack;

//初始化堆栈
Stack CreateStack()
{
    Stack header = (Stack)malloc(sizeof(struct SNode));
    header->data = -1;
    header->next = NULL;
    return header;
}

//压栈
void Push(Stack S, int item)
{
    Stack pCurrent = (Stack)malloc(sizeof(struct SNode));
    pCurrent->data = item;
    pCurrent->next = S->next;
    S->next = pCurrent;
}

//出栈
int Pop(Stack S)
{
    Stack pCurrent;
    pCurrent = S->next;
    if (pCurrent == NULL)
    {
        printf("堆栈已空！\n");
        return NULL;
    }
    else
    {
        int item;
        item = pCurrent->data;
        S->next = pCurrent->next;
        free(pCurrent);
        return item;
    }
}

//利用堆栈实现先序遍历二叉树
void InOrderTraversal(BinTree BT)
{
    //创建二叉树辅助指针
    BinTree T = BT;
    //创建一个存二叉树数据的堆栈并初始化
    Stack S = CreateStack();
    //当二叉树节点和堆栈都不为空时
    while (T != NULL && S->next != NULL)
    {
        //如果二叉树节点左边不为空，那么就一直向左压栈
        while (T != NULL)
        {
            Push(S, T->data);
            T = T->left;
        }
        //如果二叉树节点左边为空，就让这个元素出栈，再指向右边
        if (S->next != NULL)
        {
            T = Pop(S);
            printf("%5d", T->data);
            T = T->right;
        }
    }
}

//利用堆栈实现中序遍历二叉树
void InOrderTraversal(BinTree BT)
{
    //创建二叉树辅助指针
    BinTree T = BT;
    //创建一个存二叉树数据的堆栈并初始化
    Stack S = CreateStack();
    //当二叉树节点和堆栈都不为空时
    while (T != NULL && S->next != NULL)
    {
        //如果二叉树节点左边不为空，那么就一直向左压栈
        while (T != NULL)
        {
            Push(S, T->data);
            printf("%5d", T->data);
            T = T->left;
        }
        //如果二叉树节点左边为空，就让这个元素出栈，再指向右边
        if (S->next != NULL)
        {
            T = Pop(S);
            T = T->right;
        }
    }
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//利用队列进行二叉树层序遍历

//创建二叉树结构类型
struct TreeNode
{
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//创建队列结构类型
struct Node
{
    int data;
    struct Node *next;
};

struct QNode
{
    struct Node *rear;
    struct Node *front;
};
typedef struct QNode *Queue;

//出队函数
int DeleteQ(Queue PtrQ)
{
    struct Node *front_cell;
    int front_item;
    if (PtrQ->front == NULL)
    {
        printf("队列已空！\n");
        return NULL;
    }
    front_cell = PtrQ->front;
    if (PtrQ->front == PtrQ->rear)
        PtrQ->front = PtrQ->rear = NULL;
    else
        PtrQ->front = PtrQ->front->next;
    front_item = front_cell->data;
    free(front_cell);
    return front_item;
}

//入队函数
void AddQ(Queue PtrQ, int item)
{
    struct Node *rear_cell;
    rear_cell = malloc(sizeof(struct Node));
    rear_cell->data = item;
    rear_cell->next = NULL;
    if (PtrQ->front == NULL)
    {
        PtrQ->front = rear_cell;
        PtrQ->rear = rear_cell;
        return;
    }
    else
    {
        PtrQ->rear->next = rear_cell;
        PtrQ->rear = rear_cell;
        return;
    }
}

//层序遍历二叉树函数
void LevelOrderTraversal(BinTree BT)
{
    //创建一个队列
    Queue Q;
    BinTree T = BT;
    int item;
    //如果是空树直接返回
    if (BT == NULL)
        return;
    //将树根存入队列
    AddQ(Q, T->data);
    //如果队列不空
    while (Q->front != NULL)
    {
        //输出队列首元素
        item = DeleteQ(Q);
        printf("%d ", item);
        //存入子节点
        if (T->left != NULL)
        {
            AddQ(Q, T->left->data);
            T = T->left;
        }
        if (T->right != NULL)
        {
            AddQ(Q, T->right->data);
            T = T->right;
        }
    }
}


#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//二叉搜索树的查找

//创建二叉树数据类型
struct TreeNode
{
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//二叉搜索树的递归查找函数
Position Find(int item, BinTree BST)
{
    //假如树根为空
    if (BST == NULL)
        return NULL;
    //如果待查找数大于树根元素，那么在右子树中查找
    if (item > BST->data)
        return Find(item, BST->right);
    //如果待查找数小于树根元素，那么在左子树中查找
    else if (item < BST->data)
        return Find(item, BST->left);
    //如果待查找数等于树根元素，那么返回树根
    else
        return BST;
}

//二叉搜索树的循环查找函数
Position WhileFind(int item, BinTree BST)
{
    while (BST != NULL)
    {
        if (item > BST->data)
            BST = BST->right;
        else if (item < BST->data)
            BST = BST->left;
        else
            return BST;
    }
    return NULL;
}

//二叉搜索树最小值的递归查找函数
Position FindMin(BinTree BST)
{
    //如果二叉搜索树为空
    if (BST == NULL)
        return NULL;
    //否则找到最左叶节点并返回
    if (BST->left == NULL)
        return BST;
    else
        return FindMin(BST->left);
}

//二叉搜索树最小值的循环查找函数
Position WhileFindMin(BinTree BST)
{
    if (BST == NULL)
        return NULL;
    while(BST->left != NULL)
        BST = BST->left;
    return BST;
}

//找最大值与前面同理，找最右节点就行了








#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//二叉搜索树的插入与删除

//创建二叉树数据类型
struct TreeNode
{
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//二叉搜索树的递归查找函数
Position Find(int item, BinTree BST)
{
    //假如树根为空
    if (BST == NULL)
        return NULL;
    //如果待查找数大于树根元素，那么在右子树中查找
    if (item > BST->data)
        return Find(item, BST->right);
    //如果待查找数小于树根元素，那么在左子树中查找
    else if (item < BST->data)
        return Find(item, BST->left);
    //如果待查找数等于树根元素，那么返回树根
    else
        return BST;
}

//二叉搜索树的循环查找函数
Position WhileFind(int item, BinTree BST)
{
    while (BST != NULL)
    {
        if (item > BST->data)
            BST = BST->right;
        else if (item < BST->data)
            BST = BST->left;
        else
            return BST;
    }
    return NULL;
}

//二叉搜索树最小值的递归查找函数
Position FindMin(BinTree BST)
{
    //如果二叉搜索树为空
    if (BST == NULL)
        return NULL;
    //否则找到最左叶节点并返回
    if (BST->left == NULL)
        return BST;
    else
        return FindMin(BST->left);
}

//二叉搜索树最小值的循环查找函数
Position WhileFindMin(BinTree BST)
{
    if (BST == NULL)
        return NULL;
    while(BST->left != NULL)
        BST = BST->left;
    return BST;
}

//找最大值与前面同理，找最右节点就行了

//二叉搜素树的插入函数
BinTree Insert(int item, BinTree BST)
{
    //如果树根为空，那么生成并返回一个节点的二叉搜索树
    if (BST == NULL)
    {
        BST = (BinTree)malloc(sizeof(struct TreeNode));
        BST->data = item;
        BST->left = BST->right = NULL;
    }
    //找到要插入元素的位置
    else
    {
        //如果待删除元素小于树根元素，那么在左子树中查找
        if (item < BST->data)
            //递归插入左子树
            BST->left = Insert(item, BST->left);
        //否则在右子树中查找
        else if (item > BST->data)
            BST->right = Insert(item, BST->right);
    }
    return BST;
}

//二叉搜素树的删除函数
BinTree Delete(int item, BinTree BST)
{
    Position Tmp;
    //当没找到要删除的元素时
    if (BST == NULL)
        printf("要删除的元素未找到！\n");
    //如果要删除的元素小于树根元素
    else if (item < BST->data)
        //左子树递归删除
        BST->left = Delete(item, BST->left);
    //如果大于树根元素
    else if (item > BST->right)
        //右子树递归删除
        BST->right = Delete(item, BST->right);
    //找到了要删除的节点
    else
    {
        //如果要删除结点有两个子树
        if (BST->left != NULL && BST->right != NULL)
        {
            //在删除节点的右子树中找到最小元素填充删除节点
            Tmp = FindMin(BST->right);
            BST->data = Tmp->data;
            //删除右子树中最小节点
            BST->right = Delete(BST->data, BST->right);
        }
        //如果被删除节点只有一个子树或没有子树
        else
        {
            Tmp = BST;
            //有右子树或无节点
            if (BST->left == NULL)
                BST = BST->right;
            //有左子树或无节点
            else if (BST->right == NULL)
                BST = BST->left;
            //释放内存
            free(Tmp);
        }
    }
    return BST;
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//AVL树的旋转与插入

//创建AVL树数据类型
struct AVLNode
{
    int data;
    struct AVLNode *left;
    struct AVLNode *right;
    int height;
};
typedef struct AVLNode *AVLTree;
typedef AVLTree Position;

int Max(int a, int b)
{
    return a > b ? a : b;
}

GetHeight(AVLTree A);

//LL单旋函数
AVLTree SingleLeftRotation(AVLTree A)
{
    //注意：A必须有一个左子结点B
    //将A与B做左单旋，更新A与B的高度，返回新的根结点B
    AVLTree B = A->left;
    //将B的右子树放在A的左子树上
    A->left = B->right;
    //将A放在B的右子树上
    B->right = A;
    //更新A与B的高度
    A->height = Max(GetHeight(A->left), GetHeight(A->right)) + 1;
    B->height = Max(GetHeight(B->left), A->height) + 1;
    return B;
}

//RR单旋函数
AVLTree SingleRightRotation(AVLTree A)
{
    //注意：A必须有一个右子结点B
    //将A与B做右单旋，更新A与B的高度，返回新的根结点B
    AVLTree B = A->right;
    //把B的左子树放在A的右子树上
    A->right = B->left;
    //把A放在B的左子树上
    B->left = A;
    //更新A与B的高度
    A->height = Max(GetHeight(A->left), GetHeight(A->right)) + 1;
    B->height = Max(GetHeight(B->right), A->height) + 1;
    return B;
}

//LR双旋函数
AVLTree DoubleLeftRightRotation(AVLTree A)
{
    //注意：A必须有一个左子结点B，且B必须有一个右子结点C
    //将A、B与C做两次单旋，返回新的根结点C

    //将B与C做右单旋，C被返回
    A->left = SingleRightRotation(A->left);
    //将A与C做左单旋，C被返回
    A = SingleLeftRotation(A);
    return A;
}

//RL双旋函数
AVLTree DoubleRightLeftRotation(AVLTree A)
{
    //注意：A必须有一个右子结点B，且B必须有一个左子结点C
    //将A、B与C做两次单旋，返回新的根结点C

    //将B与C做左单旋，C被返回
    A->right = SingleLeftRotation(A->right);
    //将A与C做右单旋，C被返回
    A = SingleRightRotation(A);
    return A;
}

//二叉平衡树的插入函数
AVLTree Insert(AVLTree T, int item)
{
    //将X插入AVL树T中，并且返回调整后的AVL树

    //如果该树为空树
    if (T == NULL)
    {
        //新建一个节点
        T = (AVLTree)malloc(sizeof(struct AVLNode));
        T->data = item;
        T->height = 0;
        T->left = T->right = NULL;
    }
    //如果item比树根元素小
    if (item < T->data)
    {
        //插入T的左子树
        T->left = Insert(T->left, item);
        //如果需要左旋
        if (GetHeight(T->left) - GetHeight(T->right) == 2)
            //如果item小于左子树的元素
            if (item < T->left->data)
                //左单旋
                T = SingleLeftRotation(T);
            //否则左右双旋
            else
                T = DoubleLeftRightRotation(T);
    }
    //如果比树根元素大，那么和上面类型
    else if (item > T->right)
    {
        T->right = Insert(T->right, item);
        if (GetHeight(T->right) - GetHeight(T->left) == 2)
            if (item > T->right->data)
                T = SingleRightRotation(T);
            else
                T = DoubleRightLeftRotation(T);
    }

    //每次递归更新树高
    T->height = Max(GetHeight(T->left), GetHeight(T->right)) + 1;

    return T;
}


//二叉树的一些操作



//输出二叉树的所有叶结点
//与遍历二叉树所有结点相比，只需加一个判断条件即可
void PreorderPrintLeaves(BinTree BT)
{
    if(BT)
    {
        if(!BT->Left && !BT->Right) //如果左子树和右子树都为空，那么他是叶结点
        {
            printf("%d", BT->Data);
        }
        PreorderPrintLeaves(BT->Left);
        PreorderPrintLeaves(BT->Right);
    }
}

//求二叉树的高度
//树的高度是左右子树两种中最大值加一
//可利用后序遍历递归算出高度
int GetHeight(BinTree BT)
{
    int HL, HR, MaxH;

    if(BT)
    {
        HL = GetHeight(BT->Left);   //求左子树高度
        HR = GetHeight(BT->Right);  //求右子树高度
        MaxH = HL > HR ? HL : HR;
        return (MaxH + 1);
    }
    else
        return 0;   //空树高度为0
}

//层序生成二叉树
//和层序遍历二叉树一样，需先创建一个队列，然后用队列操作
#define NoInfo 0    //用0表示没有结点

BinTree CreatBinTree()
{
    int Data;
    BinTree BT, T;
    Queue Q = CreatQueue(); //创建空队列

    //建立根节点
    scanf("%d", &Data);
    if(Data != NoInfo)
    {
        //分配根节点单元，将节点地址入队
        BT = (BinTree)malloc(sizeof(struct TNode));
        BT->Data = Data;
        BT->Left = NULL;
        BT->Right = NULL;
        AddQ(Q, BT);
    }
    else    //若第一个数据是0，则返回空树
        return NULL;
    while(!IsEmpty(Q))
    {
        T = DeleteQ(Q); //取出一个结点

        scanf("%d", &Data); //读入T的左孩子
        if(Data == NoInfo)
            T->Left = NULL;
        else
        {
            //分配新节点为出队结点左孩子，新节点入队
            T->Left = (BinTree)malloc(sizeof(struct TNode));
            T->Left->Data = Data;
            T->Left->Left = T->Left->Right = NULL;
            AddQ(T->Left);
        }

        scanf("%d", &Data);//读入T的右孩子
        if(Data == NoInfo)
            T->Right = NULL;
        else
        {
            //分配新节点为出队结点左孩子，新节点入队
            T->Right = (BinTree)malloc(sizeof(struct TNode));
            T->Right->Data = Data;
            T->Right->Left = T->Right->Right = NULL;
            AddQ(T->Right);
        }
    }
    return BT;
}

//堆的结构
struct HNode
{
    ElementType *Data;	//存储元素的数组
    int Size;			//堆当前元素个数
    int Capacity;		//堆的最大容量
};
typedef struct HNode *Heap;	//堆结构的定义
typedef Heap Max_Heap;	//最大堆
typedef Heap Min_Heap;	//最小堆

#define MAX_DATA 1000	//此值应该根据具体情况定义为大于堆中所有可能元素的值

//创建容量为Max_Size的空的最大堆
Max_Heap Create_Heap(int Max_Size)
{
    Max_Heap H = (Max_Heap)malloc(sizeof(struct HNode));
    H->Data = (ElementType *)malloc((Max_Size + 1) * sizeof(ElementType));
    H->Size = 0;
    H->Capacity = Max_Size;
    H->Data[0] = MAX_DATA;	//定义“哨兵”为大于堆中所有可能元素的值
    
    return H;
}

//判断最大堆是否已满
bool Is_Full(Max_Heap H)
{
    return (H->Size == H->Capacity);
}

//最大堆的插入
bool Insert(Max_Heap H, ElementType X)
{
    int i;
    
    if(Is_Full(H))
    {
        printf("最大堆已满\n");
        return false;
    }
    i = H->Size + 1;	//i指向插入后堆中最后一个元素的位置
    for( ; H->Data[i / 2] < X; i /= 2)
        H->Data[i] = H->Data[i / 2];	//上滤X
    H->Data[i] = X;		//将X插入
    
    return true;
}

//判断最大堆是否为空
bool Is_Empty(Max_Heap H)
{
    return (H->Size == 0);
}

#define ERROR -1	//错误标识应定义为堆中不可能出现的元素

//取出键值最大的元素，并删除一个结点
ElementType Delete_Max(Max_Heap H)
{
    int Parent, Child;
    ElementType Max_Item, X;
    
    if(Is_Empty(H))
    {
        printf("最大堆已空\n");
        return ERROR;
    }
    
    Max_Item = H->Data[1];	//取出根节点存放的最大值
    //用最大堆最后一个元素放在根节点，然后下滤结点
    X = H->Data[H->Size];
    H->Size--;	//规模要减少
    for(Parent = 1; Parent * 2 <= H->Size; Parent = Child)
    {
        Child = Parent * 2;
        if((Child != H->Size) && (H->Data[Child] < H->Data[Child + 1]))	
            Child++;	//Child指向左右子树的较大者
        if(X >= H->Data[Child])
           break;	//找到了合适位置
        else	//下滤
            H->Data[Parent] = H->Data[Child];
    }
    H->Data[Parent] = X;
    
    return Max_Item;
}

//最大堆的建立
//第一步：将N个元素按顺序存入二叉树中，这一步只要求满足完全二叉树的特性，不管它是否有序
//第二步：调整各节点元素，以满足最大堆特性
//这种方法比一个一个插入元素高效
void Perc_Down(Max_Heap H, int p)
{
    //下滤：将H中以H->Data[p]为根的子堆调整为最大堆
    int Parent, Child;
    ElementType X;
    
    X = H->Data[p];	//取出根节点存放的值
    for(Parent = p; Parent * 2 <= H->Size; Parent = Child)
    {
        Child = Parent * 2;
        if((Child != H->Size) && (H->Data[Child] < H->Data[Child + 1]))
            Child++;
        if(X > H->Data[Parent])
            break;
        else
            H->Data[Parent] = H->Data[Child];
    }
    H->Data[Parent] = X;
}

void Build_Heap(Max_Heap H)
{
    //调整堆中的元素，使其满足最大堆特性
    //这里假设所有元素已存入堆中
    
    int i;
    
    for(i = H->Size / 2; i > 0; i--)
    {
        //从最后一个结点的父结点开始，到根节点1
        Perc_Down(H, i);
    }
}

struct HTNode
{
    int Weight;		//结点权值
    struct HTNode *Left;	//指向左子树
    struct HTNode *Right;	//指向右子树
};
typedef struct HTNode *Huffman_Tree;	//哈夫曼树类型

Huffman_Tree Huffman(MinHeap H)
{
    //这里最小堆的元素类型为Huffman_Tree
    //假设H->size个权值已经存进H->Data[]->Weight中
    int i, N;
    Huffman_Tree T;
    
    Build_Heap(H);	//将H->Data[]按权值Weight调整为最小堆
    N = H->Size;
    for(i = 1; i < N; i++)
    {
        //做H->Size-1次合并
        T = (Huffman_Tree)malloc(sizeof(struct HTNode));	//建立一个新节点
        T->Left = Delete_Min(H);	//从最小堆中拿出最小权值作为T的左子树
        T->Right = Delete_Min(H);	//从最小堆中拿出最小权值作为T的右子树
        T->Weight = T->Left->Weight + T->Right->Weight;	//权值相加
        Insert(H, T);	//将新T插入最小堆
    }
    return Delete_Min(H);	//返回哈夫曼树根节点指针
}

#include<stdio.h>
#include<stdlib.h>
//创建二叉树结构
struct TNode
{
    int Data;
    struct TNode *Left;
    struct TNode *Right;
};
typedef struct TNode *Bin_Tree;

//利用中序和后序遍历结果创建二叉树
Bin_Tree Build(int post_order[], int in_order[], int post_start, int post_end, int in_start, int in_end);
//先序遍历
void Preorder_Traversal(Bin_Tree BT);
//根据后序和中序遍历输出先序遍历
int main()
{
    //输入结点个数
    int N, i;
    scanf("%d", &N);

    int post_order[N];   //后序遍历结果
    int in_order[N];    //中序遍历结果

    for(i = 0; i < N; i++)
    {
        scanf("%d", &post_order[i]);
    }

    for (int i = 0; i < N; i++) 
    {
        scanf("%d", &in_order[i]);
    }
    //利用中序和后序遍历结果创建二叉树
    Bin_Tree BT = Build(post_order, in_order, 0, N - 1, 0, N - 1);
    //先序遍历二叉树
    printf("Preorder:");
    Preorder_Traversal(BT);
    return 0;
}

Bin_Tree Build(int post_order[], int in_order[], int post_start, int post_end, int in_start, int in_end)
{
    // 如果后序遍历的起始位置大于结束位置，说明已经没有节点了，返回NULL
    if (post_start > post_end) 
    {
        return NULL;
    }
    //创建根节点
    //后序遍历得最后一个数就是根节点
    Bin_Tree BT = (Bin_Tree)malloc(sizeof(struct TNode));
    BT->Data = post_order[post_end];
    BT->Left = NULL;
    BT->Right = NULL;

    //找到根节点在中序遍历的位置
    int root;
    for(root = in_start; root <= in_end; root++)
    {
        if(in_order[root] == BT->Data)
            break;
    }

    //计算左子树结点的个数
    int left_size = root - in_start;

    //递归创建左子树和右子树
    BT->Left = Build(post_order, in_order, post_start, post_start + left_size - 1, in_start, root - 1);
    BT->Right = Build(post_order, in_order, post_start + left_size, post_end - 1, root + 1, in_end);

    return BT;
}

void Preorder_Traversal(Bin_Tree BT)
{
    if(BT == NULL)
        return;
    printf(" %d", BT->Data);
    Preorder_Traversal(BT->Left);
    Preorder_Traversal(BT->Right);
}


//邻接矩阵的存储结构
#define MaxVertexNum 100	//定义顶点的最大数
typedef char VertexType;	//顶点的数据类型
typedef int EdgeType;	//带权图中边上权值的数据类型
struct GNode
{
    VertexType Vex[MaxVertexNum];	//顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];`//邻接矩阵，边表
    int vexnum;	//顶点数
    int arcnum;	//边数
};
typedef struct GNode MGraph;	//图类型

//创建图

#defind IFINITY 65535	//将无穷设为无符号整数最大值
typedef int Vertex;	//用顶点下标表示顶点，为整型

//边的定义
struct ENode
{
    Vertex V1, V2;	//有向边<V1, V2>
    WeightType Weight;	//边的权值
};
typedef struct ENode *Edge;

//初始化一个有VertexNum个顶点但没有边的图
MGraph CreateGragh(int VertexNum)
{
    Vertex V, W;
    MGraph Graph;
    
    Graph = (MGraph)malloc(sizeof(struct GNode));	//建立图
    Graph->vexnum = VertexNum;
   	Graph->arcnum = 0;
    //初始化邻接矩阵
    for(V = 0; V < Graph->vexnum; V++)
        for(W = 0; W < Graph->arcnum; W++)
            Graph->G[V][W] = INFINITY;
    
    return Graph;
}

//插入边
void InsertEdge(MGraph Graph, Egde E)
{
    Graph->G[E->V1][E->V2] = E->Weight;
}

//构建图
MGraph BuildGraph()
{
    MGraph Graph;
    Edge E;
    Vertex V;
    int Nv, i;
    
    printf("输入顶点个数：");
    scanf("%d", &Nv);
    
    Graph = CreateGraph(Nv);	//初始化图
    
    printf("输入边数：");
    scanf("%d", &(Graph->arcnum));
    if(Graph->arcnum != 0)	//如果有边
    {
        E = (Edge)malloc(sizeof(struct ENode));
        //读入边
        for(i = 0; i < Graph->arcnum; i++)
        {
            printf("输入起点、终点、权重：");
            scanf("%d %d %d", &E->V1, &E->V2, &E->Weight);
            //插入边
            InsertEdge(Graph, E);
        }
    }
    //读入顶点数据
    for(V = 0; V < Graph->vexnum; V++)
    {
        printf("输入顶点数据：");
        scanf("%c", &Graph->Vex[V]);
    }
    return Graph;
}




#define MaxVertexNum 100	//最大顶点数设为100
typedef int Vertex;		//用顶点下标表示顶点
typedef int WeightType;		//边的权值设为整型
typedef char DataType;		//顶点存储数据类型设为字符型

//边的定义
struct ENode
{
    Vertex V1, V2;		//边<v1, v2>
    WeightType Weight;	//边的权值
};
typedef struct ENode *Edge;		//设置为边结构

//边表的定义
struct AdjVNode
{
    Vertex V;				//顶点下标
    WeightType Weight;		//边权值
    struct AdjVNode *Next;	//指向下一邻接结点的指针
};
typedef struct AdjVNode *AdjV;	//设置为邻接点结点结构

//顶点表头定义
struct VNode
{
    Adjv FristEdge;		//指向下一邻接结点的指针
    Datatype Data;		//结点权值
};
typedef struct VNode AdjList[MaxVertexNum];	//设置为邻接表结构

//图节点定义
struct GNode
{
    int VertexNum;	//顶点数
    int EdgeNum;	//边数
    AdjList AL;		//邻接表
};
typedef struct GNode *LGraph;	//设置为邻接表图类型

//创建没有边的图
LGraph CreateLGraph(int VertexNum)
{
    int i;
    LGraph G;	//创建图
    G = (LGraph)malloc(sizeof(strcut GNode));	//赋予空间
    G->VertexNum = MaxVertexNum;	//输入顶点数
    G->EdgeNum = 0;	//边为0
    //给每个表头置空
    for(i = 0; i < G->VertexNum; i++)
        G->AL[i] = NULL;
    
    return G;
}

//插入边
void InsertEdge(LGraph G, Edge E)
{
    //当图为有向图时，插入边<v1, v2>
    AdjV NewNode;	//建立V2结点
    NewNode = (AdjV)malloc(sizeof(struct AdjVNode));	//赋予空间
    NewNode->V = E->V2;		//存入下标
    NewNode->Weight = E->Weight;	//存入边权值
    //将邻接结点插入头节点V1
    NewNode->Next = G->AL[E->V1].FirstEdge;
    G->AL[E->V1].FirstEdge = NewNode;
    
    //如果图为无向图，还需把V1插入V2
    AdjV New2;
    New2 = (AdjV)malloc(sizeof(struct AdjVNode));
    New2->V = E->V1;
    New2->Weight = E->Weight;
    New2->Next = G->AL[E->V2].FirstEdge;
    G->AL[E->V2].FirstEdge = New2;
}

//创建图·
LGraph BuildLGraph()
{
    int i, VertexNum;
    LGraph G;
    Edge E;
    
    printf("请输入顶点数：");
    scanf("%d", &VertexNum);
    G = CreateLGraph(VertexNum);
    
    printf("请输入边数：");
    scanf("%d", &G->EdgeNum);
    
    if(G->EdgeNum != 0)
    {
        E = (Edge)malloc(sizeof(struct ENode));
        for(i = 0; i < G->EdgeNum; i++)
        {
            scanf("%d%d%d", &E->V1, &E->V2, &E->Weight);
            InsertEdge(G, E);
        }
    }
    
    return Graph;
}


//假设图以邻接表的形式储存

//Visited数组记录顶点的探索情况,预先将所有顶点设置为未探索
bool Visited[MaxVertexNum] = {false};

//访问顶点函数
void Visit(Vertex V)
{
    printf("正在访问结点%d\n", V);
}

//DFS函数深度优先搜索
void DFS(LGraph G, Vertes V)
{
    //从顶点V出发对图G进行DFS搜索
    AdjV W;
    
    //访问节点V
    Visit(V);
    //标记该节点
    Visited[V] = true;
    
    //对V的邻接点进行访问
    for(W = G->AL[V].FirstEdge; W; W->Next)
    {
        //当顶点未被访问时
        if(Visited[W->V] == false)
            //递归访问
            DFS(G, W->V);
    }
}



//假设图以邻接矩阵的方式存储

//Visited数组记录顶点的探索情况,预先将所有顶点设置为未探索
bool Visited[MaxVertexNum] = {false};

//判断<V,W>是否是边
bool IsEdge(MGraph G, Vertex V, Vertex W)
{
    return (G->Edge[V][W] < INFINITY ? true : false);
}

//以S为出发点对图进行BFS搜索
void BFS(MGraph G, Vertex S)
{
    Queue Q;
    Vertex V, W;
    
    //创建一个空队列
    Q = CreateQueue();
    Visit(S);	//访问该顶点
    //标记该顶点
    Visited[S] = true;
    //S入队
    AddQ(Q, S);
    
    //层序遍历顶点
    while(!IsEmpty(Q))
    {
        //当Q不为空时
        V = DeleteQ(Q);	//弹出顶点
        //找到Q的所有邻接点放入队列
        for(W = 0; W < MGraph->VertexNum; W++)
        {
            if(!Visit[W] && IsEdge(G, V, W))
            {
                Visit(W);
                Visited[W] = true;
                AddQ(W);
            }
        }
    }
}





//最小生成树肯定是稀疏图，所以最小生成树用邻接表储存
//这里用邻接矩阵储存原图

#defind ERROR -1	//错误标记，表示生成树不存在

//prime算法，将图的最小生成树保存到邻接表储存的图MST中，返回最小权值或错误信息
int Prim(MGraph G, LGraph MST)
{
    //定义一个数组用来存放下标代表的顶点到其父结点的权值
    //定义最小权值和
    WeightType dist[MaxVertexNum], TotalWeight = 0;
    //定义一个数组来存放下标代表的顶点的父结点
    Vertex parant[MaxVertexNum], V, W;
    int VCount;		//VCount表示收录顶点的数量
    Edge E;
    
    //将所有顶点的父结点初始化为V0,并把每个顶点到v0的权值存入
    for(V = 0; V < G->VertexNum; V++)
    {
        dist[V] = G->Edge[0][V];
        parant[V] = 0;
    }
    VCount = 0;
    
    //创建一个空的邻接表来表示MST
    MST = CreateLGragh(G->VertexNum);
    E = (Edge)malloc(sizeof(struct ENode));
    
    dist[0] = 0;	//表示V0已被收录
    VCount++;
    parant[0] = -1;		//表示当前树根为V0
    
    //核心代码，收录最小权值并更新未收录顶点的父结点
    while(1)
    {
        V = FindMinDist(G, dist);	//找到dist中的最小权值
        if(V == ERROR)
            break;	//如果最小权值不存在，则结束算法
        //将V和相应的边<parant[V], V>收录进MST
        E->V1 = parent[V];
        E->V2 = V;
        E->Weight = dist[V];
        InsertEdge(MST, E);
        TotalWeight += dist[V];
        dist[V] = 0;	//标记V顶点已被收录
        VCount++;
        
        //找到与当上一个被收录顶点相邻的的所有未收录顶点
        //如果有未收录顶点到上一个被收录节点的边权值比dist数组存的数小，那么更新dist数组，并更新该未收录顶点的父结点
        for(W = 0; W < G->VertexNum; V++)
        {
            if(G->Edge[V][W] < dist[W])
            {
                dist[W] = G->Edge[V][W];
                parant[W] = V;
            }
        }
    }//while结束
    
    //如果收录的顶点未满就返回错误信息
    if(VCount < G->VertexNum)
        return ERROR;
    //否则返回最小权值总和
    return TotalWeight;
}

//返回dist中未收录顶点最小顶点
Vertex FindMinDist(MGraph G, WeightType dist[])
{
    Vertex MinV, V;
    WeightType MinDist = INFINITY;
    
    for(V = 0; V < G->VertexNum; V++)
    {
        if(dist[V] != 0 && dist[V] < MinDist)
        {
            MinDist = dist[V];
            MinV = V；
        }
    }
    if(MinDist < INFINITY)
        return MinV;
    else
        return ERROR;
}






//这里用邻接表储存原图和最小生成树

int Kruskal(LGraph G, LGraph MST)
{
    //初始化空MST
    MST = CreateLGraph(G->VertexNum);
    //设置权重和
    WeightType Vcount = 0;
    //设置parant数组，并将其初始化
    int parant[G->VertexNum] = -1;
    //设置一个边集，把图的所有边存入边集
    Edge E[G->EdgeNum]；
    CreateEdge(G, E);
    //构造一个包含原图所有边的最小堆
    MinHeap H = BuildMinHeap(E);
    //while循环构造最小生成树
    while(MST->EdgeNum < G->Vertex - 1 && G->EdgeNum != 0)
    {
        //从最小堆取一个边
        Edge E0 = DeleteMinHeap(H);
        //原图边集中删掉这个边
        DeleteEdge(G, E0);
        //确认这个边是否会让MST形成回路
        if(!Find(parant, E0))
        //是则丢弃该边
        //否则将这个边加入MST，并标记顶点
        {
            InsertLGraph(MST, E);
            if(parant[E->V1] == -1)
                parant[E->V1] = E->V2;
            if(parant[E->V2] == -1)
                parant[E->V2] = E->V1;
        }
        //增加权重和
        Vcount += E->Weight;
        //增加MST收集的边数
    }
    //如果MST收集的边不足则返回错误信息
    if(MST->EdgeNum != G->NertexNum)
        return ERROR;
    else
        return Vcount;
    //否则返回权重和
}

//将图G的边存入边集E中
void CreateEdge(LGraph G, Edge E[])
{
    Vertex V, W = 0;
    for(V = 0; V < G->VerNum; V++)
    {
        AdjV H = G->AL[V]->FirstEdge;
        while(H != NULL)
        {
            E[W]->V1 = V;
        	E[W]->V2 = H->V;
            E[W]->Weight = H->Weight;
            W++;
            H = H->Next;
        }
    }
}

//构造一个包含原图所有边的最小堆
MinHeap BuildMinHeap(E[]);
{
    MinHeap H = CreateMinHeap(G->EdgeNum);
    int i;
    for(i = 0; i < G->EdgeNum; i++)
    {
        H->Data[i] = E[i];
    }
    return H;
}



//利用Dijkstra算法求单源最短路径
//这里图用邻接矩阵存储
#defind ERROR -1	//设置报错符号
#defind INF	65535	//指定权值为无穷的边为INF

//构建最短路径结构
struct MLNode
{
    //源顶点和终顶点
    Vertex HomeV;
    Vertex EndV;
    //包含最短路径中所有经过的顶点的数组
    Vertex *SumV;
    //顶点个数
    int VerNum;
    //路径总长度
    WeightType SumLength;
};
typedef struct MLNode *MinL;
//求最短路径函数,函数形参是图、起始顶点和最终顶点
MinL MinLength(MGraph G, Vertex HV, Vertex EV)
{
    //创建一个长度为G->VertexNum的一个parent数组，用来存每个顶点对应的父结点
    int parent[G->VertexNum];
    //创建一个长度为VertexNum的一个dist数组，用来存每个顶点到其父结点的权值
    int dist[G->VertexNum];
    //利用Dijkatra算法得到parent数组和dist中的元素
    Dijkatra(G, HV, dist, parent);
    //调用FindSumV函数得到MinL->SumV和Min->VerNum
    Vertex *SV;
    int VN = FindSumV(EV, parent, SV);
    //调用FindSumL函数得到SumLength
    WeightType SL = FindSumL(dist, SV);
    //初始化MinL
    MinL ML = CreateMinL(ML, HV, EV, SV, VN, SL);
    return ML;
}

//Dijkatra算法,构造dist数组和parent数组
void Dijkatra(MGraph G, Vertex HV, int dist[], int parent[])
{
    Vertex V, W;
    //设置一个mark数组，用来标记已收录的顶点
    int mark[G->VertexNum];
    //初始化dist数组，将每个顶点到源顶点的权值存入
    //初始化parent数组，将与源节点邻接的顶点的父结点设为源节点，不邻接的设为-1
    //初始化mark数组，将所有顶点设置为未收录
    for(V = 0; V < G->VertexNum; V++)
    {
        dist[V] = G->Edge[HV][V];
        if(dist[V] < INF)
            parent[V] = HV;
        else
            parent[V] = -1;
        mark[V] = 0;
    }
    //标记源顶点
    dist[HV] = 0;
    mark[V] = 1;
    //利用while函数循环收录顶点
    while(1)
    {
        //调用FindMinDist函数找与父结点最小邻接边的顶点V
        V = FindMinDist(G, dist, mark);
        //没找到则结束循环
        if(V == ERROR)
            break;
        //找到了则标记该顶点V已收录
        mark[V] = 1;
        //利用for循环找能够让dist变小的顶点
        for(W = 0; W < G->VertexNum; W++)
        {
            //如果循环到的邻接顶点的邻接边小于其父结点的邻接边
            if(G->Edge[V][W] < dist[W])
            {
                //将该边替换
                dist[W] = G->Edge[V][W];
                //更新parent数组
                parent[W] = V;
            }
        }
    }
}

//从dist数组找未收录最小顶点
Vertex FindMinDist(MGraph G, dist[], mark[])
{
    int i, minV = 0;
    int flag = 0;
    for(i = 0; i < G->VertexNum; i++)
    {
        if(mark[i] && dist[minV] > dist[i])
        {
            flag = 1;
            minV = i;
        }
    }
    if(flag == 1)
        return minV;
    else
        return ERROR;
}





//Floyd算法求各个顶点最短路径
//这里图用邻接矩阵储存
void Floyd(MGraph G, WeightType dis[][MaxVertexNum], Vertex path[][MaxVertexNum])
{
    Vertex i, j, K;	
    
    //初始化最短路径图dis，将图G复制到dis
    for(i = 0; i < G->VertexNum; i++)
        for(j = 0; j < G->VertexNum; j++)
        {
            dis[i][j] = G->Edge[i][j];
            //初始化中转顶点表path
            path[i][j] = -1;
        }
    
    //循环每个中转顶点
    for(k = 0; k < G->VertexNum; k++)
        //循环每条邻接边，找到他们的中转顶点
        for(i = 0; i < G->VertexNum; i++)
            for(j = 0; j < G->VertexNum; j++)
            {
                //如果i到j的路径比i到k再到j的路径长，就更新i到j的路径
                if(dis[i][k] + dis[k][j] < dis[i][j])
                {
                    dis[i][j] = dis[i][k] + dis[k][j];
                    //更新中转顶点
                    path[i][j] = k;
                }
            }
    //最终path[i][j]存的中转顶点是邻接于顶点i的
}

//利用中转顶点表来找最短路径路程
void Find(MGraph G, path[][MaxVertexNum], Vertex VH, Vertex VE);
{
    printf("%d ", HV);
    Vertex k = path[VH][VE];
    while(K != -1)
    {
        printf("-> %d ", k);
        k = path[k][HE];
    }
    printf("-> %d\n", HE);
}



//拓扑排序排列有向无环图
//这里用邻接表表示图
bool TopSort(MGraph G, Vertex TopOrder)
{
    //对图G进行拓扑排序，排序后的顶点放入TopOrder数组
    Vertex TopOrder[G->VertexNum];
    //遍历图，得到所有顶点的入度，并存入Indegree数组
    Vertex Indegree[G->VertexNum];
    Vertex V, W;
    for(V = 0; V < G->VertexNum; V++)
    	for(W = G->AL[V].FirstEdge; W == NULL; W = W->Next)
        {
            Indegree[W->AdjV]++;
        }
    //创建队列，并将所有入度为0的顶点入队
    Queue Q = CreateQueue(G->VertexNum);
    for(V = 0; V < G->VertexNum; V++)
    {
        if(Indegree[V] == 0)
            AddQ(Q, V);
    }
    //核心代码
    //设置一个计数器来观察所有出过队的顶点数量
    int cnt = 0;
    //while循环来实现拓扑排序
    while(!IsEmpty(Q))	//当队列为空时说明没有入度为0的顶点，退出循环
    {
        //出队一个顶点，把它存入TopOrder数组，并将计数器加一
        V = DeleteQ(Q);
        TopOrder[cnt] = V;
        cnt++;
        //把这个顶点的邻接顶点的入度数减一，并且把入度减少后度数为0的邻接顶点入队
        for(W = G->AL[V].FirstEdge; W; W++)
        {
            Indegree[W->AdjV]--;
            if(Indegree[W->AdjV] == 0)
                AddQ(Q, W->AdjV);
        }
    }
    //如果计数器计算的顶点小于原图中顶点数量，说明原图有回路，返回false
    if(cnt < G->VertexNum)
        return false;
    else
        return tru
    //结束算法
}