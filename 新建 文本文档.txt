#include <stdio.h>
#include <math.h>
#include <string.h>
//静态链表的遍历
void text();
struct LintNode
{
	int date;
	struct LintNode *next;
};

void text()
{
	struct LintNode node1 = {10, NULL};
	struct LintNode node2 = {20, NULL};
	struct LintNode node3 = {30, NULL};
	struct LintNode node4 = {40, NULL};
	struct LintNode node5 = {50, NULL};
	struct LintNode node6 = {60, NULL};

	node1.next = &node2;
	node2.next = &node3;
	node3.next = &node4;
	node4.next = &node5;
	node5.next = &node6;

	struct LintNode *p_current = &node1;
	while (p_current != NULL)
	{
		printf("%d ", p_current -> date);
		p_current = p_current -> next;
	}
}

int main()
{
	text();

	return 0;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//初始化动态链表, 并且遍历链表
struct LinkNode *Init_LinkList();
void Foreach_LinkList(struct LinkNode *header);

struct LinkNode
{
	int date;
	struct LinkNode *next;
};
//初始化链表
struct LinkNode *Init_LinkList()
{
	//创建头节点并分配空间
	struct LinkNode *header = malloc(sizeof(struct LinkNode));
	header -> date = -1;
	header -> next = NULL;
	//创建尾部指针
	struct LinkNode *pRear = header;
	//创建新节点并向其输入数据
	int val = 1;
	while (val != -1)
	{
		printf("请输入新的数据：\n");
		scanf("%d", &val);
		if (val == -1)
			break;
		//创建节点
		struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
		new_node -> date = val;
		new_node -> next = NULL;
		//将新节点插入前面
		pRear -> next = new_node;
		//移动尾部指针
		pRear = new_node;
	}
	//返回头节点地址
	return header;
}
//遍历链表
void Foreach_LinkList(struct LinkNode *header)
{
	if (header == NULL)
		return;
	//辅助指针变量
	struct LinkNode *pCurrent = header -> next;
	while (pCurrent != NULL)
	{
		printf("%d ", pCurrent -> date);
		pCurrent = pCurrent -> next;
	}
}

int main()
{
	//初始化链表
	struct LinkNode *header = Init_LinkList();
	//遍历链表
	Foreach_LinkList(header);
	return 0;
}



//插入新节点
void Insert_val(struct LinkNode *header, int old_val, int new_val)
{
    if (header == NULL)
        return;
    //构造两个指针变量，两指针变量相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到old val，并让pCurrent指向old val
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == old_val)
            break;
        
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    //如果pCurrent为NULL， 那么不插入
    if (pCurrent == NULL)
        return;
    //创建新节点
    struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
    new_node -> date = new_val;
    new_node -> next = NULL;
    //将新节点放在old node前一格
    pPrev -> next = new_node;
    new_node -> next = pCurrent;
}


//清空链表
void Clear_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;

    //创建辅助指针变量，使之指向头节点下一个节点
    struct LinkNode *pCurrent = header -> next;
    //逐个清空节点
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放当前节点内存
        free(pCurrent);
        //pCurrent指向下一个节点
        pCurrent = pNext;
    }
    //让头节点指向空
    header -> next = NULL;
}
	



//删除节点
void Delete_val(struct LinkNode *header, int del_val)
{
    if (header == NULL)
        return;
    //创建两个辅助指针变量使之相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到要删除的节点
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == del_val)
            break;
        //移动两个指针
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    if (pCurrent == NULL)
        return;
    //删除节点
    pPrev -> next = pCurrent -> next;
    free(pCurrent);
    pCurrent = NULL;
}

//销毁链表
void Destroy_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;
    //创建辅助指针变量
    struct LinkNode *pCurrent = header;
    //依次释放每个节点的内存
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放该节点内存
        free(pCurrent);
        //指向下一节点
        pCurrent = pNext;
    }
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//初始化动态链表
struct LinkNode *Init_LinkList();
//遍历链表
void Foreach_LinkList(struct LinkNode *header);
//插入节点
void Insert_val(struct LinkNode *header, int old_val, int nem_val);
//清空链表
void Clear_LinkList(struct LinkNode *header);
//删除节点
void Delete_val(struct LinkNode *header, int del_val);
//销毁链表
void Destroy_LinkList(struct LinkNode *header);

struct LinkNode
{
	int date;
	struct LinkNode *next;
};

//初始化链表
struct LinkNode *Init_LinkList()
{
	//创建头节点并分配空间
	struct LinkNode *header = malloc(sizeof(struct LinkNode));
	header -> date = -1;
	header -> next = NULL;
	//创建尾部指针
	struct LinkNode *pRear = header;
	//创建新节点并向其输入数据
	int val = 1;
	while (val != -1)
	{
		printf("请输入新的数据：\n");
		scanf("%d", &val);
		if (val == -1)
			break;
		//创建节点
		struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
		new_node -> date = val;
		new_node -> next = NULL;
		//将新节点插入前面
		pRear -> next = new_node;
		//移动尾部指针
		pRear = new_node;
	}
	//返回头节点地址
	return header;
}

//遍历链表
void Foreach_LinkList(struct LinkNode *header)
{
	if (header == NULL)
		return;
	//辅助指针变量
	struct LinkNode *pCurrent = header -> next;
	while (pCurrent != NULL)
	{
		printf("%d ", pCurrent -> date);
		pCurrent = pCurrent -> next;
	}
}

//插入新节点
void Insert_val(struct LinkNode *header, int old_val, int new_val)
{
    if (header == NULL)
        return;
    //构造两个指针变量，两指针变量相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到old val，并让pCurrent指向old val
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == old_val)
            break;
        
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    //如果pCurrent为NULL， 那么不插入
    if (pCurrent == NULL)
        return;
    //创建新节点
    struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
    new_node -> date = new_val;
    new_node -> next = NULL;
    //将新节点放在old node前一格
    pPrev -> next = new_node;
    new_node -> next = pCurrent;
}

//清空链表
void Clear_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;

    //创建辅助指针变量，使之指向头节点下一个节点
    struct LinkNode *pCurrent = header -> next;
    //逐个清空节点
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放当前节点内存
        free(pCurrent);
        //pCurrent指向下一个节点
        pCurrent = pNext;
    }
    //让头节点指向空
    header -> next = NULL;
}

//删除节点
void Delete_val(struct LinkNode *header, int del_val)
{
    if (header == NULL)
        return;
    //创建两个辅助指针变量使之相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到要删除的节点
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == del_val)
            break;
        //移动两个指针
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    if (pCurrent == NULL)
        return;
    //删除节点
    pPrev -> next = pCurrent -> next;
    free(pCurrent);
    pCurrent = NULL;
}

//销毁链表
void Destroy_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;
    //创建辅助指针变量
    struct LinkNode *pCurrent = header;
    //依次释放每个节点的内存
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放该节点内存
        free(pCurrent);
        //指向下一节点
        pCurrent = pNext;
    }
}
int main()
{
	//初始化链表
	struct LinkNode *header = Init_LinkList();
	//遍历链表
	Foreach_LinkList(header);
    //插入新节点
    printf("输入新的数据：\n");
    int new_val;
    scanf("%d", &new_val);
    Insert_val(header, 600, new_val);
    printf("\n-------------------\n");
    //再次遍历链表
    Foreach_LinkList(header);
    //删除某个节点
    printf("\n输入你要删除的数据：\n");
    int del_val;
    scanf("%d", &del_val);
    Delete_val(header, del_val);
    //再次遍历链表
    Foreach_LinkList(header);
    //清空链表
    printf("\n是否清空链表？请输入yes或no：\n");
    char str[5];
    getchar();
    gets(str);
    if (strcmp(str, "yes") == 0)
    {    Clear_LinkList(header);
        //再次遍历链表检查是否清空链表
        Foreach_LinkList(header);
    }
    else if(strcmp(str, "no") == 0)
    {
        Foreach_LinkList(header);
    }
	return 0;
}

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define MAX_SIZE 30
//创建线性表结构类型
struct LNode
{
    //创建数组
    int Data[MAX_SIZE];
    //记录最后数据下标
    int Last;
};
//定义结构指针
typedef struct LNode *List;

//初始化线性表
List MarkEmpty();
//查找数据
int Find(int x, List PtrL);
//插入数据
void Insert(int x, int i, List PtrL);
//删除元素
void Delete(int i, List PtrL);

//初始化线性表
List MarkEmpty()
{
    //创建线性表
    List PtrL;
    //分配空间
    PtrL = (List)malloc(sizeof(struct LNode));
    PtrL -> Last = -1;
    return PtrL;
}

//查找数据
int Find(int x, List PtrL)
{
    int i = 0;
    //逐个查找数据
    while (i <= PtrL -> Last && PtrL -> Data[i] != x)
    {
        i++;
    }
    //如果没找到，返回-1, 否则返回i
    if (i > PtrL -> Last)
        return -1;
    else    
        return i + 1;
}

//插入数据
void Insert(int x, int i, List PtrL)
{
    int j;
    //判断线性表是否装满
    if (PtrL -> Last == MAX_SIZE - 1)
    {
        printf("线性表已满\n");
        return;
    }
    //检查插入位置的合法性
    if (i < 1 || i > PtrL->Last + 2)
    {
        printf("位置不合法！");
        return;
    }
    for (j = PtrL -> Last; j >= i - 1; j--)
    {
        PtrL -> Data[j + 1] = PtrL -> Data[j];
    }
    //插入新元素
    PtrL -> Data[i - 1] = x;
    //Last仍指向最后元素
    PtrL -> Last++;
}

//删除元素
void Delete(int i, List PtrL)
{
    int j;
    //检查空表及删除位置
    if (i < 1 || i > PtrL->Last + 1)
    {
        printf("不存在第%d个元素", i);
        return;
    }
    //将每个删除位置后的元素向前移一个
    for (j = i; j <= PtrL->Last; j++)
    {
        PtrL->Data[j - 1] = PtrL->Data[j];
    }
    //让Last指向最后一个数据
    PtrL->Last--;
}

int main()
{
    struct LNode *L;
    L = MarkEmpty();
    L->Last = 20;
    int i;

    printf("请输入数组元素：\n");
    for (i = 0; i < L->Last; i++)
    {
        scanf("%d", &L->Data[i]);
    }

    for (i = 0; i < L->Last; i++)
    {
        printf("%d ", L->Data[i]);
    }

    //查找元素位置
    int find;
    printf("\n输入待查找元素：\n");
    scanf("%d", &find);
    find = Find(find, L);
    printf("%d\n", find);

    int X;
    printf("请输入插入元素和插入位置：\n");
    scanf("%d%d", &X, &i);
    Insert(X, i, L);

    for (i = 0; i < L->Last; i++)
    {
        printf("%d ", L->Data[i]);
    }

    printf("\n请输入删除位置：\n");
    scanf("%d", &i);
    Delete(i, L);

    for (i = 0; i < L->Last; i++)
    {
        printf("%d ", L->Data[i]);
    }
    return 0;
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//堆栈的实现
//创建顺序类型堆栈

//创建顺序类型堆栈数据结构
struct SNode
{
    //创建存储数据的数组
    int *date;
    //创建栈顶指针
    int top;
    //堆栈最大容量
    int max_size;
};
typedef struct SNode *Stack;

//初始化顺序栈
Stack CreateStack(int max_size)
{
    //给线性表分配内存
    Stack S = (Stack)malloc(sizeof(struct SNode));
    //给数组分配内存
    S->date = (int *)malloc(max_size * sizeof(int));
    S->max_size = max_size;
    //将top调到-1
    S->top = -1;
    return S;
}

//入栈操作Push
void Push(int item, Stack PtrL)
{
    //判断堆栈满没满，满则退出，没满则入栈
    if (PtrL->top == PtrL->max_size - 1)
    {
        printf("堆栈已满！\n");
        return;
    }
    else
    {
        PtrL->top++;
        PtrL->date[PtrL->top] = item;
        return;
    }
}

//出栈操作Pop
int Pop(Stack PtrL)
{
    //判断堆栈是否为空
    if (PtrL->top == -1)
    {
        printf("堆栈为空！\n");
        return NULL;
    }
    else
    {
        int item;
        item = PtrL->date[PtrL->top];
        PtrL->top--;
        return item;
    }
}

int main()
{
    int max_size, i, s;
    printf("输入栈的长度：\n");
    scanf("%d", &max_size);
    struct SNode *stack1 = CreateStack(max_size);
    for (i = 1; i <= max_size; i++)
    {
        s = i * 2 + 1;
        Push(s, stack1);
    }
    int item;
    item = Pop(stack1);
    while (item != NULL)
    {
        printf("%d ", item);
        item = Pop(stack1);
    }
    return 0;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//堆栈的实现
//创建顺序类型堆栈

//创建二项顺序类型堆栈数据结构
struct SNode
{
    //创立储存元素的数组
    int *data;
    //创建两个栈顶指针，一个在表前，一个在表后
    int top1;
    int top2;
    //堆栈长度
    int max_size;
};
typedef struct SNode *Stack;

//创建双向堆栈
Stack CreateStackTwo(int max_size)
{
    //给堆栈分配内存
    Stack S = (Stack)malloc(sizeof(struct SNode));
    //给数组分配内存
    S->data = (int *)malloc(max_size * sizeof(int));
    S->max_size = max_size;
    //将top1调到-1
    S->top1 = -1;
    //将top2调到max_size
    S->top2 = max_size;
    return S;
}

//双向堆栈入栈操作
void PushTwo(Stack PtrL, int item, int Tag)
{
    //判断堆栈是否堆满
    if (PtrL->top1 + 1 == PtrL->top2)
    {
        printf("堆栈已满！\n");
        return;
    }
    else
    {   //Tag作为区分两个堆栈的标志，取值为1和2
        if (Tag == 1)
        {
            PtrL->top1++;
            PtrL->data[PtrL->top1] = item;
        }
        else
        {
            PtrL->top2--;
            PtrL->data[PtrL->top2] = item;
        }
    }
}

//双向堆栈出栈操作
int PopTwo(Stack PtrL, int Tag)
{
    int item;
   //Tag作为区分两个堆栈的标志，取值为1和2
   if (Tag == 1)
   {
        //判断第一个堆栈是否为空
        if (PtrL->top1 == -1)
        {
            printf("堆栈1已空！\n");
            return NULL;
        }
        else
        {
            item = PtrL->data[PtrL->top1];
            PtrL->top1--;
            return item;
        }
   } 
   else
   {
        //判断第二个堆栈是否为空
        if (PtrL->top2 == PtrL->max_size)
        {
            printf("堆栈2已空！\n");
            return NULL;
        }
        else
        {
            item = PtrL->data[PtrL->top2];
            PtrL->top2++;
            return item;
        }
   }
}

int main()
{
    int max_size, i, s1, s2;
    printf("输入栈的长度：\n");
    scanf("%d", &max_size);
    struct SNode *stack1 = CreateStackTwo(max_size);
    for (i = 1; i <= max_size / 2; i++)
    {
        s1 = i * 2 + 1;
        PushTwo(stack1, s1, 1);
    }
    for (i = max_size / 2 + 1; i <= max_size; i++)
    {
        s2 = i + 2;
        PushTwo(stack1, s2, 2);
    }

    int item;
    item = PopTwo(stack1, 1);
    while (item != NULL)
    {
        printf("%d ", item);
        item = PopTwo(stack1, 1);
    }
    printf("\n");
    item = PopTwo(stack1, 2);
    while (item != NULL)
    {
        printf("%d ", item);
        item = PopTwo(stack1, 2);
    }
    return 0;
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//堆栈的链式储存实现
//创建链栈的数据结构
struct SNode
{
    int data;
    struct SNode *next;
};
typedef struct SNode *Stack;

//创建堆栈头节点
Stack CreateStack()
{
    Stack header;
    //给头节点分配内存
    header = (Stack)malloc(sizeof(struct SNode));
    header->data = -1;
    header->next = NULL;
    return header;
}

//将元素压入栈顶
void Push(Stack S, int item)
{
    //创建辅助指针
    Stack pCurrent;
    //创建节点
    pCurrent = (Stack)malloc(sizeof(struct SNode));
    pCurrent->data = item;
    //将头节点后的数据放在新节点后面
    pCurrent->next = S->next;
    S->next = pCurrent;
}

//删除并返回栈顶元素
int Pop(Stack S)
{
    //创建辅助堆栈指针1
    Stack pCurrent;
    pCurrent = S->next;
    //判断堆栈是否为空
    if (pCurrent->data == -1)
    {
        printf("堆栈已空！\n");
        return NULL;
    }
    else
    {
        int item;
        //删除并返回数据
        
        S->next = pCurrent->next;
        item = pCurrent->data;
        //释放指向节点内存
        free(pCurrent);
        //返回数据
        return item;
    }
}

int main()
{
    Stack PtrL;
    PtrL = CreateStack();
    int item, i;
    for (i = 1; i <= 10; i++)
    {
        //输入数据，压入栈中
        printf("请输入数据：\n");
        scanf("%d", &item);
        Push(PtrL, item);
    }
    item = Pop(PtrL);
    while (item != NULL)
    {
        printf("%d ", item);
        item = Pop(PtrL);
    }
    return 0;
}




#include <stdio.h>
#include <math.h>
#include <string.h>

//至诚图书管理系统
int main()
{
    printf("-----------------欢迎来到至诚图书库！-----------------\n");
    int s_number = 1;
    int Allow = 0;
    //创建用户名数组和密码数组
    char username[20][20];
    char password[20][15];
    //创建图书库
    char books[7][50] = {"十二国记", "青春猪头少年不会梦到兔女郎学姐", "浪客剑心", "白色相簿2", "孤独摇滚", "寒蝉鸣泣之时", "命运石之门"};
    //我的图书库
    char my_books[7][50] = {0};
    int i = 0, j = 0, k = 0;
    while (s_number != 0)
    {
        printf("请选择您的需求：（输入数字即可：）\n");
        printf("1.注册\n");
        printf("2.登录\n");
        printf("3.借书\n");
        printf("4.还书\n");
        printf("0.退出程序\n");
        //输入序号
        scanf("%d", &s_number);
        //注册程序
        while (s_number == 1)
        {
            printf("请输入您的用户名：");
            scanf("%s", username[i]);
            printf("请输入您的密码：");
            scanf("%s", password[i]);
            if(username[i][0] == '\0' || password[i][0] == '\0')
            {
                printf("注册失败！请重新注册！\n");
            }
            else if (i == 20)
            {
                printf("账号已满，无法继续注册\n");
                s_number = -1;
            }
            else
            {
                printf("注册成功！\n\n\n");
                s_number = -1;
                i++;
            }
        }
        //登录程序
        while (s_number == 2)
        {
            int flag1 = 0, flag2 = 0;
            char p_username[20];
            char p_password[15];
            char yes_no[5] = {0};
            printf("请输入您的用户名：");
            scanf("%s", p_username);
            printf("请输入您的密码：");
            scanf("%s", p_password);
            //从用户名数组和密码数组中查找此账号
            for (j = 0; j <= i; j++)
            {
                if (strcmp(username[j], p_username) == 0)
                    flag1 = 1;
                if (strcmp(password[j], p_password) == 0)
                    flag2 = 1;
                if (flag1 == 1 && flag2 == 1)
                {
                    printf("登录成功！\n\n\n");
                    Allow = 1;
                    s_number = -1;
                    break;
                }
            }
            if (flag1 != 1 || flag2 != 1)
            {
                printf("登录失败！\n");
                printf("您是否要退出登录，还是重新登录（输入yes或no)：");
                scanf("%s", yes_no);
                if (strcmp(yes_no, "yes") == 0)
                {
                    s_number = -1;
                    break;
                }
            }
        }
        //借书程序
        while (s_number == 3)
        {
            //判断是否登录
            if (Allow != 1)
            {
                printf("请登录后再使用！\n");
                s_number = -1;
                break;
            }
            else
            {
            	char yes_no[5] = {0};
                printf("本馆目前库存如下：\n");
                //打印书单
                for (k = 0; k < 7; k++)
                {
                    if (books[k][0] == '\0')
                        break;
                    printf("%d.%s\n", k + 1, books[k]);
                }
                printf("\n\n\n");
                //借书
                do
                {
                    if (books[0][0] == '\0')
                    {
                        printf("图书馆已空，无法借书！\n");
                        s_number = -1;
                        break;
                    }
                    printf("请输入您要借的书的序号：");
                    int book_number;
                    
                    scanf("%d", &book_number);
                    //判断借书是否成功
                    if (books[book_number - 1][0] == '\0')
                    {
                        printf("暂无此书！\n");
                        printf("您是否要继续借书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                    else
                    {
                        //将图书馆书籍放入我的借书库中
                        for (k = 0; k < 7; k++)
                        {
                            if (my_books[k][0] == '\0')
                            {
                                strcpy(my_books[k], books[book_number - 1]);
                                break;
                            }
                        }
                        printf("借书成功！\n\n\n");
                        //整理图书馆
                        if (books[book_number][0] == '\0' || book_number == 7)
                        {
                        	books[book_number - 1][0] = '\0';
						}
						else
						{
	                        while (books[book_number][0] != '\0')
	                        {
	                            strcpy(books[book_number - 1], books[book_number]);
	                            books[book_number][0] = '\0';
	                            book_number++;
	                        }
	                    }
                        //写出现有书单
                        printf("现在的库存有：\n");
                        for (k = 0; k < 7; k++)
                        {
                            if (books[k][0] == '\0')
                                break;
                            printf("%d.%s\n", k + 1, books[k]);
                        }
                        printf("\n\n\n");
                        //是否继续借书
                        printf("您是否要继续借书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                }while (strcmp(yes_no, "yes") == 0);
                if (strcmp(yes_no, "no") == 0)
                    s_number = -1;
            }
        }
        //还书程序
        while (s_number == 4)
        {
            //判断是否登录
            if (Allow != 1)
            {
                printf("请登录后再使用！\n");
                s_number = -1;
                break;
            }
            else
            {
                char yes_no[5] = {0};
                printf("您已借的图书有：\n");
                //打印书单
                for (k = 0; k < 7; k++)
                {
                    if (my_books[k][0] == '\0')
                        break;
                    printf("%d.%s\n", k + 1, my_books[k]);
                }
                printf("\n\n\n");
                //还书
                do
                {
                    if (my_books[0][0] == '\0')
                    {
                        printf("暂无借书，无法还书！\n");
                        s_number = -1;
                        break;
                    }
                    printf("请输入您要还的书的序号：");
                    int book_number;
                    
                    scanf("%d", &book_number);
                    //判断还书是否成功
                    if (my_books[book_number - 1][0] == '\0')
                    {
                        printf("暂无此书！\n");
                        printf("您是否要继续还书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                    else
                    {
                        //将我借的书籍放入图书馆中
                        for (k = 0; k < 7; k++)
                        {
                            if (books[k][0] == '\0')
                            {
                                strcpy(books[k], my_books[book_number - 1]);
                                break;
                            }
                        }
                        printf("还书成功！\n\n\n");
                        //整理我的结束库
                        if (my_books[book_number][0] == '\0' || book_number == 7)
                        {
                        	my_books[book_number - 1][0] = '\0';
						}
						else
						{
	                        while (my_books[book_number][0] != '\0')
	                        {
	                            strcpy(my_books[book_number - 1], my_books[book_number]);
	                            my_books[book_number][0] = '\0';
	                            book_number++;
	                        }
	                    }
                        //写出现有书单
                        printf("现在的借书有：\n");
                        for (k = 0; k < 7; k++)
                        {
                            if (my_books[k][0] == '\0')
                                break;
                            printf("%d.%s\n", k + 1, my_books[k]);
                        }
                        printf("\n\n\n");
                        //是否继续借书
                        printf("您是否要继续还书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                }while (strcmp(yes_no, "yes") == 0);
                if (strcmp(yes_no, "no") == 0)
                    s_number = -1;

            }
        }
    }
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//循环队列的创建与插入的删除

//创建顺序结构数据类型
struct SNode
{
    int data[10];
    //创建头元素位置变量
    int front;
    //创建尾元素变量
    int rear;
};
typedef struct SNode *QNode;

//入队列函数
void AddQ(QNode PtrQ, int item)
{
    //判断队列满没满
    if ((PtrQ->rear + 1) % 10 == PtrQ->front)
    {
        printf("队列已满！\n");
        return;
    }
    //将新增元素放在队尾，并将队尾变量加一
    PtrQ->rear = (PtrQ->rear + 1) % 10;
    PtrQ->data[PtrQ->rear] = item;
}

//出队列函数
int DeleteQ(QNode PtrQ)
{
    //判断队列空没空
    if (PtrQ->front == PtrQ->rear)
    {
        printf("队列已空！\n");
        return 1;
    }
    else
    {
        //将队首元素返回，并将队首变量加一
        PtrQ->front = (PtrQ->front + 1) % 10; 
        int item;
        item = PtrQ->data[PtrQ->front];
        return item;
    }    
}

int main()
{
    QNode p_arr = (QNode)malloc(sizeof(struct SNode));
    p_arr->front = 0;
    p_arr->rear = 0;
    int i, item;
    for (i = 1; i <= 9; i++)
    {
        scanf("%d", &item);
        AddQ(p_arr, item);
    }
    for (i = 1; i <= 9; i++)
    {
        item = DeleteQ(p_arr);
        printf("%d ", item);
    }
    return 0;
} 




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//队列的链式存储实现

//创建基本数据类型
struct Node
{
    int data;
    struct Node *next;
};
//创建队列指针数据类型
struct QNode
{
    //创建队尾指针
    struct Node *rear;
    //创建队首指针
    struct Node *front;
};
typedef struct QNode *Queue;

//出队函数
int DeleteQ(Queue PtrQ)
{
    //创建队首指针和队首数据域变量
    struct Node *front_cell;
    int front_item;
    //判断队列是否为空
    if (PtrQ->front == NULL)
    {
        printf("队列已空！\n");
        return 0;
    }
    //让队首指针指向要删除节点
    front_cell = PtrQ->front;
    //如果队列只有一个元素，删除后让队列为空,否则头节点指向下一个节点
    if (PtrQ->front == PtrQ->rear)
        PtrQ->front = PtrQ->rear = NULL;
    else
        PtrQ->front = PtrQ->front->next;
    //将要删除元素赋给队首数据域变量
    front_item = front_cell->data;
    //释放待删除节点内存
    free(front_cell);
    //返回数据域变量
    return front_item;
}

//入队函数
void AddQ(Queue PtrQ, int item)
{
    //创建节点辅助指针
    struct Node *pCurrent;
    //为其分配内存，并将数据存入数据域
    pCurrent = malloc(sizeof(struct Node));
    pCurrent->data = item;
    pCurrent->next = NULL;
    //假如队列为空
    if (PtrQ->front == NULL)
    {
        PtrQ->front = pCurrent;
        PtrQ->rear = pCurrent;
        return;
    }
    else
    {
        //否则将新节点连接在队尾，并将队尾指针指向新节点
        PtrQ->rear->next = pCurrent;
        PtrQ->rear = pCurrent;
        return;
    }
}
int main()
{
    Queue PtrQ;
    PtrQ = malloc(sizeof(struct QNode));
    PtrQ->front = NULL;
    PtrQ->rear = NULL;
    int i, item;
    for (i = 1; i <= 10; i++)
    {
        scanf("%d", &item);
        AddQ(PtrQ, item);
    }
    item = DeleteQ(PtrQ);
    while (item != 0)
    {
        printf("%d ", item);
        item = DeleteQ(PtrQ);
    }
    return 0;
} 