#include <stdio.h>
#include <math.h>
#include <string.h>
//静态链表的遍历
void text();
struct LintNode
{
	int date;
	struct LintNode *next;
};

void text()
{
	struct LintNode node1 = {10, NULL};
	struct LintNode node2 = {20, NULL};
	struct LintNode node3 = {30, NULL};
	struct LintNode node4 = {40, NULL};
	struct LintNode node5 = {50, NULL};
	struct LintNode node6 = {60, NULL};

	node1.next = &node2;
	node2.next = &node3;
	node3.next = &node4;
	node4.next = &node5;
	node5.next = &node6;

	struct LintNode *p_current = &node1;
	while (p_current != NULL)
	{
		printf("%d ", p_current -> date);
		p_current = p_current -> next;
	}
}

int main()
{
	text();

	return 0;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//初始化动态链表, 并且遍历链表
struct LinkNode *Init_LinkList();
void Foreach_LinkList(struct LinkNode *header);

struct LinkNode
{
	int date;
	struct LinkNode *next;
};
//初始化链表
struct LinkNode *Init_LinkList()
{
	//创建头节点并分配空间
	struct LinkNode *header = malloc(sizeof(struct LinkNode));
	header -> date = -1;
	header -> next = NULL;
	//创建尾部指针
	struct LinkNode *pRear = header;
	//创建新节点并向其输入数据
	int val = 1;
	while (val != -1)
	{
		printf("请输入新的数据：\n");
		scanf("%d", &val);
		if (val == -1)
			break;
		//创建节点
		struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
		new_node -> date = val;
		new_node -> next = NULL;
		//将新节点插入前面
		pRear -> next = new_node;
		//移动尾部指针
		pRear = new_node;
	}
	//返回头节点地址
	return header;
}
//遍历链表
void Foreach_LinkList(struct LinkNode *header)
{
	if (header == NULL)
		return;
	//辅助指针变量
	struct LinkNode *pCurrent = header -> next;
	while (pCurrent != NULL)
	{
		printf("%d ", pCurrent -> date);
		pCurrent = pCurrent -> next;
	}
}

int main()
{
	//初始化链表
	struct LinkNode *header = Init_LinkList();
	//遍历链表
	Foreach_LinkList(header);
	return 0;
}



//插入新节点
void Insert_val(struct LinkNode *header, int old_val, int new_val)
{
    if (header == NULL)
        return;
    //构造两个指针变量，两指针变量相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到old val，并让pCurrent指向old val
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == old_val)
            break;
        
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    //如果pCurrent为NULL， 那么不插入
    if (pCurrent == NULL)
        return;
    //创建新节点
    struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
    new_node -> date = new_val;
    new_node -> next = NULL;
    //将新节点放在old node前一格
    pPrev -> next = new_node;
    new_node -> next = pCurrent;
}


//清空链表
void Clear_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;

    //创建辅助指针变量，使之指向头节点下一个节点
    struct LinkNode *pCurrent = header -> next;
    //逐个清空节点
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放当前节点内存
        free(pCurrent);
        //pCurrent指向下一个节点
        pCurrent = pNext;
    }
    //让头节点指向空
    header -> next = NULL;
}
	



//删除节点
void Delete_val(struct LinkNode *header, int del_val)
{
    if (header == NULL)
        return;
    //创建两个辅助指针变量使之相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到要删除的节点
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == del_val)
            break;
        //移动两个指针
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    if (pCurrent == NULL)
        return;
    //删除节点
    pPrev -> next = pCurrent -> next;
    free(pCurrent);
    pCurrent = NULL;
}

//销毁链表
void Destroy_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;
    //创建辅助指针变量
    struct LinkNode *pCurrent = header;
    //依次释放每个节点的内存
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放该节点内存
        free(pCurrent);
        //指向下一节点
        pCurrent = pNext;
    }
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//初始化动态链表
struct LinkNode *Init_LinkList();
//遍历链表
void Foreach_LinkList(struct LinkNode *header);
//插入节点
void Insert_val(struct LinkNode *header, int old_val, int nem_val);
//清空链表
void Clear_LinkList(struct LinkNode *header);
//删除节点
void Delete_val(struct LinkNode *header, int del_val);
//销毁链表
void Destroy_LinkList(struct LinkNode *header);

struct LinkNode
{
	int date;
	struct LinkNode *next;
};

//初始化链表
struct LinkNode *Init_LinkList()
{
	//创建头节点并分配空间
	struct LinkNode *header = malloc(sizeof(struct LinkNode));
	header -> date = -1;
	header -> next = NULL;
	//创建尾部指针
	struct LinkNode *pRear = header;
	//创建新节点并向其输入数据
	int val = 1;
	while (val != -1)
	{
		printf("请输入新的数据：\n");
		scanf("%d", &val);
		if (val == -1)
			break;
		//创建节点
		struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
		new_node -> date = val;
		new_node -> next = NULL;
		//将新节点插入前面
		pRear -> next = new_node;
		//移动尾部指针
		pRear = new_node;
	}
	//返回头节点地址
	return header;
}

//遍历链表
void Foreach_LinkList(struct LinkNode *header)
{
	if (header == NULL)
		return;
	//辅助指针变量
	struct LinkNode *pCurrent = header -> next;
	while (pCurrent != NULL)
	{
		printf("%d ", pCurrent -> date);
		pCurrent = pCurrent -> next;
	}
}

//插入新节点
void Insert_val(struct LinkNode *header, int old_val, int new_val)
{
    if (header == NULL)
        return;
    //构造两个指针变量，两指针变量相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到old val，并让pCurrent指向old val
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == old_val)
            break;
        
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    //如果pCurrent为NULL， 那么不插入
    if (pCurrent == NULL)
        return;
    //创建新节点
    struct LinkNode *new_node = malloc(sizeof(struct LinkNode));
    new_node -> date = new_val;
    new_node -> next = NULL;
    //将新节点放在old node前一格
    pPrev -> next = new_node;
    new_node -> next = pCurrent;
}

//清空链表
void Clear_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;

    //创建辅助指针变量，使之指向头节点下一个节点
    struct LinkNode *pCurrent = header -> next;
    //逐个清空节点
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放当前节点内存
        free(pCurrent);
        //pCurrent指向下一个节点
        pCurrent = pNext;
    }
    //让头节点指向空
    header -> next = NULL;
}

//删除节点
void Delete_val(struct LinkNode *header, int del_val)
{
    if (header == NULL)
        return;
    //创建两个辅助指针变量使之相邻
    struct LinkNode *pPrev = header;
    struct LinkNode *pCurrent = pPrev -> next;
    //找到要删除的节点
    while (pCurrent != NULL)
    {
        if (pCurrent -> date == del_val)
            break;
        //移动两个指针
        pPrev = pCurrent;
        pCurrent = pCurrent -> next;
    }
    if (pCurrent == NULL)
        return;
    //删除节点
    pPrev -> next = pCurrent -> next;
    free(pCurrent);
    pCurrent = NULL;
}

//销毁链表
void Destroy_LinkList(struct LinkNode *header)
{
    if (header == NULL)
        return;
    //创建辅助指针变量
    struct LinkNode *pCurrent = header;
    //依次释放每个节点的内存
    while (pCurrent != NULL)
    {
        //保存下一个节点的位置，防止失去连接
        struct LinkNode *pNext = pCurrent -> next;
        //释放该节点内存
        free(pCurrent);
        //指向下一节点
        pCurrent = pNext;
    }
}
int main()
{
	//初始化链表
	struct LinkNode *header = Init_LinkList();
	//遍历链表
	Foreach_LinkList(header);
    //插入新节点
    printf("输入新的数据：\n");
    int new_val;
    scanf("%d", &new_val);
    Insert_val(header, 600, new_val);
    printf("\n-------------------\n");
    //再次遍历链表
    Foreach_LinkList(header);
    //删除某个节点
    printf("\n输入你要删除的数据：\n");
    int del_val;
    scanf("%d", &del_val);
    Delete_val(header, del_val);
    //再次遍历链表
    Foreach_LinkList(header);
    //清空链表
    printf("\n是否清空链表？请输入yes或no：\n");
    char str[5];
    getchar();
    gets(str);
    if (strcmp(str, "yes") == 0)
    {    Clear_LinkList(header);
        //再次遍历链表检查是否清空链表
        Foreach_LinkList(header);
    }
    else if(strcmp(str, "no") == 0)
    {
        Foreach_LinkList(header);
    }
	return 0;
}

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define MAX_SIZE 30
//创建线性表结构类型
struct LNode
{
    //创建数组
    int Data[MAX_SIZE];
    //记录最后数据下标
    int Last;
};
//定义结构指针
typedef struct LNode *List;

//初始化线性表
List MarkEmpty();
//查找数据
int Find(int x, List PtrL);
//插入数据
void Insert(int x, int i, List PtrL);
//删除元素
void Delete(int i, List PtrL);

//初始化线性表
List MarkEmpty()
{
    //创建线性表
    List PtrL;
    //分配空间
    PtrL = (List)malloc(sizeof(struct LNode));
    PtrL -> Last = -1;
    return PtrL;
}

//查找数据
int Find(int x, List PtrL)
{
    int i = 0;
    //逐个查找数据
    while (i <= PtrL -> Last && PtrL -> Data[i] != x)
    {
        i++;
    }
    //如果没找到，返回-1, 否则返回i
    if (i > PtrL -> Last)
        return -1;
    else    
        return i + 1;
}

//插入数据
void Insert(int x, int i, List PtrL)
{
    int j;
    //判断线性表是否装满
    if (PtrL -> Last == MAX_SIZE - 1)
    {
        printf("线性表已满\n");
        return;
    }
    //检查插入位置的合法性
    if (i < 1 || i > PtrL->Last + 2)
    {
        printf("位置不合法！");
        return;
    }
    for (j = PtrL -> Last; j >= i - 1; j--)
    {
        PtrL -> Data[j + 1] = PtrL -> Data[j];
    }
    //插入新元素
    PtrL -> Data[i - 1] = x;
    //Last仍指向最后元素
    PtrL -> Last++;
}

//删除元素
void Delete(int i, List PtrL)
{
    int j;
    //检查空表及删除位置
    if (i < 1 || i > PtrL->Last + 1)
    {
        printf("不存在第%d个元素", i);
        return;
    }
    //将每个删除位置后的元素向前移一个
    for (j = i; j <= PtrL->Last; j++)
    {
        PtrL->Data[j - 1] = PtrL->Data[j];
    }
    //让Last指向最后一个数据
    PtrL->Last--;
}

int main()
{
    struct LNode *L;
    L = MarkEmpty();
    L->Last = 20;
    int i;

    printf("请输入数组元素：\n");
    for (i = 0; i < L->Last; i++)
    {
        scanf("%d", &L->Data[i]);
    }

    for (i = 0; i < L->Last; i++)
    {
        printf("%d ", L->Data[i]);
    }

    //查找元素位置
    int find;
    printf("\n输入待查找元素：\n");
    scanf("%d", &find);
    find = Find(find, L);
    printf("%d\n", find);

    int X;
    printf("请输入插入元素和插入位置：\n");
    scanf("%d%d", &X, &i);
    Insert(X, i, L);

    for (i = 0; i < L->Last; i++)
    {
        printf("%d ", L->Data[i]);
    }

    printf("\n请输入删除位置：\n");
    scanf("%d", &i);
    Delete(i, L);

    for (i = 0; i < L->Last; i++)
    {
        printf("%d ", L->Data[i]);
    }
    return 0;
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//堆栈的实现
//创建顺序类型堆栈

//创建顺序类型堆栈数据结构
struct SNode
{
    //创建存储数据的数组
    int *date;
    //创建栈顶指针
    int top;
    //堆栈最大容量
    int max_size;
};
typedef struct SNode *Stack;

//初始化顺序栈
Stack CreateStack(int max_size)
{
    //给线性表分配内存
    Stack S = (Stack)malloc(sizeof(struct SNode));
    //给数组分配内存
    S->date = (int *)malloc(max_size * sizeof(int));
    S->max_size = max_size;
    //将top调到-1
    S->top = -1;
    return S;
}

//入栈操作Push
void Push(int item, Stack PtrL)
{
    //判断堆栈满没满，满则退出，没满则入栈
    if (PtrL->top == PtrL->max_size - 1)
    {
        printf("堆栈已满！\n");
        return;
    }
    else
    {
        PtrL->top++;
        PtrL->date[PtrL->top] = item;
        return;
    }
}

//出栈操作Pop
int Pop(Stack PtrL)
{
    //判断堆栈是否为空
    if (PtrL->top == -1)
    {
        printf("堆栈为空！\n");
        return NULL;
    }
    else
    {
        int item;
        item = PtrL->date[PtrL->top];
        PtrL->top--;
        return item;
    }
}

int main()
{
    int max_size, i, s;
    printf("输入栈的长度：\n");
    scanf("%d", &max_size);
    struct SNode *stack1 = CreateStack(max_size);
    for (i = 1; i <= max_size; i++)
    {
        s = i * 2 + 1;
        Push(s, stack1);
    }
    int item;
    item = Pop(stack1);
    while (item != NULL)
    {
        printf("%d ", item);
        item = Pop(stack1);
    }
    return 0;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//堆栈的实现
//创建顺序类型堆栈

//创建二项顺序类型堆栈数据结构
struct SNode
{
    //创立储存元素的数组
    int *data;
    //创建两个栈顶指针，一个在表前，一个在表后
    int top1;
    int top2;
    //堆栈长度
    int max_size;
};
typedef struct SNode *Stack;

//创建双向堆栈
Stack CreateStackTwo(int max_size)
{
    //给堆栈分配内存
    Stack S = (Stack)malloc(sizeof(struct SNode));
    //给数组分配内存
    S->data = (int *)malloc(max_size * sizeof(int));
    S->max_size = max_size;
    //将top1调到-1
    S->top1 = -1;
    //将top2调到max_size
    S->top2 = max_size;
    return S;
}

//双向堆栈入栈操作
void PushTwo(Stack PtrL, int item, int Tag)
{
    //判断堆栈是否堆满
    if (PtrL->top1 + 1 == PtrL->top2)
    {
        printf("堆栈已满！\n");
        return;
    }
    else
    {   //Tag作为区分两个堆栈的标志，取值为1和2
        if (Tag == 1)
        {
            PtrL->top1++;
            PtrL->data[PtrL->top1] = item;
        }
        else
        {
            PtrL->top2--;
            PtrL->data[PtrL->top2] = item;
        }
    }
}

//双向堆栈出栈操作
int PopTwo(Stack PtrL, int Tag)
{
    int item;
   //Tag作为区分两个堆栈的标志，取值为1和2
   if (Tag == 1)
   {
        //判断第一个堆栈是否为空
        if (PtrL->top1 == -1)
        {
            printf("堆栈1已空！\n");
            return NULL;
        }
        else
        {
            item = PtrL->data[PtrL->top1];
            PtrL->top1--;
            return item;
        }
   } 
   else
   {
        //判断第二个堆栈是否为空
        if (PtrL->top2 == PtrL->max_size)
        {
            printf("堆栈2已空！\n");
            return NULL;
        }
        else
        {
            item = PtrL->data[PtrL->top2];
            PtrL->top2++;
            return item;
        }
   }
}

int main()
{
    int max_size, i, s1, s2;
    printf("输入栈的长度：\n");
    scanf("%d", &max_size);
    struct SNode *stack1 = CreateStackTwo(max_size);
    for (i = 1; i <= max_size / 2; i++)
    {
        s1 = i * 2 + 1;
        PushTwo(stack1, s1, 1);
    }
    for (i = max_size / 2 + 1; i <= max_size; i++)
    {
        s2 = i + 2;
        PushTwo(stack1, s2, 2);
    }

    int item;
    item = PopTwo(stack1, 1);
    while (item != NULL)
    {
        printf("%d ", item);
        item = PopTwo(stack1, 1);
    }
    printf("\n");
    item = PopTwo(stack1, 2);
    while (item != NULL)
    {
        printf("%d ", item);
        item = PopTwo(stack1, 2);
    }
    return 0;
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//堆栈的链式储存实现
//创建链栈的数据结构
struct SNode
{
    int data;
    struct SNode *next;
};
typedef struct SNode *Stack;

//创建堆栈头节点
Stack CreateStack()
{
    Stack header;
    //给头节点分配内存
    header = (Stack)malloc(sizeof(struct SNode));
    header->data = -1;
    header->next = NULL;
    return header;
}

//将元素压入栈顶
void Push(Stack S, int item)
{
    //创建辅助指针
    Stack pCurrent;
    //创建节点
    pCurrent = (Stack)malloc(sizeof(struct SNode));
    pCurrent->data = item;
    //将头节点后的数据放在新节点后面
    pCurrent->next = S->next;
    S->next = pCurrent;
}

//删除并返回栈顶元素
int Pop(Stack S)
{
    //创建辅助堆栈指针1
    Stack pCurrent;
    pCurrent = S->next;
    //判断堆栈是否为空
    if (pCurrent->data == -1)
    {
        printf("堆栈已空！\n");
        return NULL;
    }
    else
    {
        int item;
        //删除并返回数据
        
        S->next = pCurrent->next;
        item = pCurrent->data;
        //释放指向节点内存
        free(pCurrent);
        //返回数据
        return item;
    }
}

int main()
{
    Stack PtrL;
    PtrL = CreateStack();
    int item, i;
    for (i = 1; i <= 10; i++)
    {
        //输入数据，压入栈中
        printf("请输入数据：\n");
        scanf("%d", &item);
        Push(PtrL, item);
    }
    item = Pop(PtrL);
    while (item != NULL)
    {
        printf("%d ", item);
        item = Pop(PtrL);
    }
    return 0;
}




#include <stdio.h>
#include <math.h>
#include <string.h>

//至诚图书管理系统
int main()
{
    printf("-----------------欢迎来到至诚图书库！-----------------\n");
    int s_number = 1;
    int Allow = 0;
    //创建用户名数组和密码数组
    char username[20][20];
    char password[20][15];
    //创建图书库
    char books[7][50] = {"十二国记", "青春猪头少年不会梦到兔女郎学姐", "浪客剑心", "白色相簿2", "孤独摇滚", "寒蝉鸣泣之时", "命运石之门"};
    //我的图书库
    char my_books[7][50] = {0};
    int i = 0, j = 0, k = 0;
    while (s_number != 0)
    {
        printf("请选择您的需求：（输入数字即可：）\n");
        printf("1.注册\n");
        printf("2.登录\n");
        printf("3.借书\n");
        printf("4.还书\n");
        printf("0.退出程序\n");
        //输入序号
        scanf("%d", &s_number);
        //注册程序
        while (s_number == 1)
        {
            printf("请输入您的用户名：");
            scanf("%s", username[i]);
            printf("请输入您的密码：");
            scanf("%s", password[i]);
            if(username[i][0] == '\0' || password[i][0] == '\0')
            {
                printf("注册失败！请重新注册！\n");
            }
            else if (i == 20)
            {
                printf("账号已满，无法继续注册\n");
                s_number = -1;
            }
            else
            {
                printf("注册成功！\n\n\n");
                s_number = -1;
                i++;
            }
        }
        //登录程序
        while (s_number == 2)
        {
            int flag1 = 0, flag2 = 0;
            char p_username[20];
            char p_password[15];
            char yes_no[5] = {0};
            printf("请输入您的用户名：");
            scanf("%s", p_username);
            printf("请输入您的密码：");
            scanf("%s", p_password);
            //从用户名数组和密码数组中查找此账号
            for (j = 0; j <= i; j++)
            {
                if (strcmp(username[j], p_username) == 0)
                    flag1 = 1;
                if (strcmp(password[j], p_password) == 0)
                    flag2 = 1;
                if (flag1 == 1 && flag2 == 1)
                {
                    printf("登录成功！\n\n\n");
                    Allow = 1;
                    s_number = -1;
                    break;
                }
            }
            if (flag1 != 1 || flag2 != 1)
            {
                printf("登录失败！\n");
                printf("您是否要退出登录，还是重新登录（输入yes或no)：");
                scanf("%s", yes_no);
                if (strcmp(yes_no, "yes") == 0)
                {
                    s_number = -1;
                    break;
                }
            }
        }
        //借书程序
        while (s_number == 3)
        {
            //判断是否登录
            if (Allow != 1)
            {
                printf("请登录后再使用！\n");
                s_number = -1;
                break;
            }
            else
            {
            	char yes_no[5] = {0};
                printf("本馆目前库存如下：\n");
                //打印书单
                for (k = 0; k < 7; k++)
                {
                    if (books[k][0] == '\0')
                        break;
                    printf("%d.%s\n", k + 1, books[k]);
                }
                printf("\n\n\n");
                //借书
                do
                {
                    if (books[0][0] == '\0')
                    {
                        printf("图书馆已空，无法借书！\n");
                        s_number = -1;
                        break;
                    }
                    printf("请输入您要借的书的序号：");
                    int book_number;
                    
                    scanf("%d", &book_number);
                    //判断借书是否成功
                    if (books[book_number - 1][0] == '\0')
                    {
                        printf("暂无此书！\n");
                        printf("您是否要继续借书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                    else
                    {
                        //将图书馆书籍放入我的借书库中
                        for (k = 0; k < 7; k++)
                        {
                            if (my_books[k][0] == '\0')
                            {
                                strcpy(my_books[k], books[book_number - 1]);
                                break;
                            }
                        }
                        printf("借书成功！\n\n\n");
                        //整理图书馆
                        if (books[book_number][0] == '\0' || book_number == 7)
                        {
                        	books[book_number - 1][0] = '\0';
						}
						else
						{
	                        while (books[book_number][0] != '\0')
	                        {
	                            strcpy(books[book_number - 1], books[book_number]);
	                            books[book_number][0] = '\0';
	                            book_number++;
	                        }
	                    }
                        //写出现有书单
                        printf("现在的库存有：\n");
                        for (k = 0; k < 7; k++)
                        {
                            if (books[k][0] == '\0')
                                break;
                            printf("%d.%s\n", k + 1, books[k]);
                        }
                        printf("\n\n\n");
                        //是否继续借书
                        printf("您是否要继续借书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                }while (strcmp(yes_no, "yes") == 0);
                if (strcmp(yes_no, "no") == 0)
                    s_number = -1;
            }
        }
        //还书程序
        while (s_number == 4)
        {
            //判断是否登录
            if (Allow != 1)
            {
                printf("请登录后再使用！\n");
                s_number = -1;
                break;
            }
            else
            {
                char yes_no[5] = {0};
                printf("您已借的图书有：\n");
                //打印书单
                for (k = 0; k < 7; k++)
                {
                    if (my_books[k][0] == '\0')
                        break;
                    printf("%d.%s\n", k + 1, my_books[k]);
                }
                printf("\n\n\n");
                //还书
                do
                {
                    if (my_books[0][0] == '\0')
                    {
                        printf("暂无借书，无法还书！\n");
                        s_number = -1;
                        break;
                    }
                    printf("请输入您要还的书的序号：");
                    int book_number;
                    
                    scanf("%d", &book_number);
                    //判断还书是否成功
                    if (my_books[book_number - 1][0] == '\0')
                    {
                        printf("暂无此书！\n");
                        printf("您是否要继续还书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                    else
                    {
                        //将我借的书籍放入图书馆中
                        for (k = 0; k < 7; k++)
                        {
                            if (books[k][0] == '\0')
                            {
                                strcpy(books[k], my_books[book_number - 1]);
                                break;
                            }
                        }
                        printf("还书成功！\n\n\n");
                        //整理我的结束库
                        if (my_books[book_number][0] == '\0' || book_number == 7)
                        {
                        	my_books[book_number - 1][0] = '\0';
						}
						else
						{
	                        while (my_books[book_number][0] != '\0')
	                        {
	                            strcpy(my_books[book_number - 1], my_books[book_number]);
	                            my_books[book_number][0] = '\0';
	                            book_number++;
	                        }
	                    }
                        //写出现有书单
                        printf("现在的借书有：\n");
                        for (k = 0; k < 7; k++)
                        {
                            if (my_books[k][0] == '\0')
                                break;
                            printf("%d.%s\n", k + 1, my_books[k]);
                        }
                        printf("\n\n\n");
                        //是否继续借书
                        printf("您是否要继续还书（输入yes或no）:");
                        scanf("%s", yes_no);
                    }
                }while (strcmp(yes_no, "yes") == 0);
                if (strcmp(yes_no, "no") == 0)
                    s_number = -1;

            }
        }
    }
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//循环队列的创建与插入的删除

//创建顺序结构数据类型
struct SNode
{
    int data[10];
    //创建头元素位置变量
    int front;
    //创建尾元素变量
    int rear;
};
typedef struct SNode *QNode;

//入队列函数
void AddQ(QNode PtrQ, int item)
{
    //判断队列满没满
    if ((PtrQ->rear + 1) % 10 == PtrQ->front)
    {
        printf("队列已满！\n");
        return;
    }
    //将新增元素放在队尾，并将队尾变量加一
    PtrQ->rear = (PtrQ->rear + 1) % 10;
    PtrQ->data[PtrQ->rear] = item;
}

//出队列函数
int DeleteQ(QNode PtrQ)
{
    //判断队列空没空
    if (PtrQ->front == PtrQ->rear)
    {
        printf("队列已空！\n");
        return 1;
    }
    else
    {
        //将队首元素返回，并将队首变量加一
        PtrQ->front = (PtrQ->front + 1) % 10; 
        int item;
        item = PtrQ->data[PtrQ->front];
        return item;
    }    
}

int main()
{
    QNode p_arr = (QNode)malloc(sizeof(struct SNode));
    p_arr->front = 0;
    p_arr->rear = 0;
    int i, item;
    for (i = 1; i <= 9; i++)
    {
        scanf("%d", &item);
        AddQ(p_arr, item);
    }
    for (i = 1; i <= 9; i++)
    {
        item = DeleteQ(p_arr);
        printf("%d ", item);
    }
    return 0;
} 




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//队列的链式存储实现

//创建基本数据类型
struct Node
{
    int data;
    struct Node *next;
};
//创建队列指针数据类型
struct QNode
{
    //创建队尾指针
    struct Node *rear;
    //创建队首指针
    struct Node *front;
};
typedef struct QNode *Queue;

//出队函数
int DeleteQ(Queue PtrQ)
{
    //创建队首指针和队首数据域变量
    struct Node *front_cell;
    int front_item;
    //判断队列是否为空
    if (PtrQ->front == NULL)
    {
        printf("队列已空！\n");
        return 0;
    }
    //让队首指针指向要删除节点
    front_cell = PtrQ->front;
    //如果队列只有一个元素，删除后让队列为空,否则头节点指向下一个节点
    if (PtrQ->front == PtrQ->rear)
        PtrQ->front = PtrQ->rear = NULL;
    else
        PtrQ->front = PtrQ->front->next;
    //将要删除元素赋给队首数据域变量
    front_item = front_cell->data;
    //释放待删除节点内存
    free(front_cell);
    //返回数据域变量
    return front_item;
}

//入队函数
void AddQ(Queue PtrQ, int item)
{
    //创建节点辅助指针
    struct Node *pCurrent;
    //为其分配内存，并将数据存入数据域
    pCurrent = malloc(sizeof(struct Node));
    pCurrent->data = item;
    pCurrent->next = NULL;
    //假如队列为空
    if (PtrQ->front == NULL)
    {
        PtrQ->front = pCurrent;
        PtrQ->rear = pCurrent;
        return;
    }
    else
    {
        //否则将新节点连接在队尾，并将队尾指针指向新节点
        PtrQ->rear->next = pCurrent;
        PtrQ->rear = pCurrent;
        return;
    }
}
int main()
{
    Queue PtrQ;
    PtrQ = malloc(sizeof(struct QNode));
    PtrQ->front = NULL;
    PtrQ->rear = NULL;
    int i, item;
    for (i = 1; i <= 10; i++)
    {
        scanf("%d", &item);
        AddQ(PtrQ, item);
    }
    item = DeleteQ(PtrQ);
    while (item != 0)
    {
        printf("%d ", item);
        item = DeleteQ(PtrQ);
    }
    return 0;
} 





#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
//比较函数
int Compare(int a, int b);
//置尾函数
void Attach(int a, int b, Polynomial *p);

//多项式加法运算

//创建多项式数据类型
struct PolyNode
{
    //系数
    int coef;
    //指数
    int expon;
    //指向下一个节点的指针
    struct PolyNode *next;
};
typedef struct PolyNode *Polynomial;
Polynomial p1, p2;

//置尾函数
void Attach(int a, int b, Polynomial p)
{
    //创建多项式节点
    Polynomial P;
    //为新节点赋予内存和赋值
    P = (Polynomial)malloc(sizeof(struct PolyNode));
    P->coef = a;
    P->expon = b;
    P->next = NULL;
    p->next = P;
    p = P;
}
//多项式相加函数
Polynomial PolyAdd(Polynomial p1, Polynomial p2)
{
    //创建和多项式链表头节点和尾节点
    Polynomial front, rear, temp;
    //定义系数和变量
    int sum;
    //给头节点赋予内存
    front = (Polynomial)malloc(sizeof(struct PolyNode));
    rear = front;
    //当p1和p2都没加完时
    while (p1 != NULL && p2 != NULL)
    {
        //对p1指向节点的指数和p2的相比较
        switch(Compare(p1->expon, p2->expon))   //Compare函数需自己实现
        //当p1指向节点的指数大于p2时
        case 1:
            //将p1指向的节点放到和多项式链表表尾
            Attach(p1->coef, p1->expon, rear);
            //将p1向后移
            p1 = p1->next;
            break;
        //当p1指向节点的指数小于p2时
        case -1:
            //将p2指向的节点放到和多项式链表表尾
            Attach(p2->coef, p2->expon, rear);
            //将p2向后移
            p2 = p2->next;
            break;
        //当p1指向节点的指数等于于p2时
        case 0:
            //将p1和p2所指向节点的系数相加
            sum = p1->coef + p2->coef;
            //如果和不为0
            if (sum != 0)
                Attach(sum, p1->expon, rear);
            //将p1和p2向后移
            p1 = p1->next;
            p2 = p2->next;
            break;
    }
    //如果某个多项式加完了，那么就将另一个多项式剩余的项放在和多项式后面
    if (p1 == NULL)
    {
        Attach(p2->coef, p2->expon, rear);
        p2 = p2->next;
    }
    if (p2 = NULL)
    {
        Attach(p1->coef, p1->expon, rear);
        p1 = p1->next;
    }
    //将和多项式尾部节点指向空
    rear->next = NULL;
    //销毁头节点，并返回和多项式表头
    temp = front;
    front = front->next;
    free(temp);
    return front;
}


#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10
//静态查找

//定义数组数据类型
struct Node
{
    int arr[Max_size];
    int length;
};
typedef struct Node *List;
List PtrQ;

//顺序查找函数
int Sqt_srch(List PtrQ, int K)
{
    int i;
    //建立哨兵，碰到哨兵退出循环
    PtrQ->arr[0] = K;
    //从末尾向前查找
    for (i = PtrQ->length; PtrQ->arr[i] != K; i--)
        return i;
    if (i == 0)
        return 0;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10
//二分查找法

//定义数组数据类型
struct Node
{
    int arr[Max_size];
    int length;
};
typedef struct Node *List;
List PtrQ;

//二分查找函数
//数组内元素一定是从小到大排序好的
int BinarySearch(List PtrQ, int K)
{
    //定义左变量，右变量，中间变量
    int left, right, mid;
    left = 1;
    right = PtrQ->length;
    //当右变量下标大于左变量的时
    while (left <= right)
    {
        //计算中间变量下标
        mid = (left + right) / 2;
        //如果K大于中间变量
        if (K > PtrQ->arr[mid])
            left = mid + 1;
        //如果K小于中间变量
        else if (K < PtrQ->arr[mid])
            right = mid - 1;
        //如果K等于中间变量
        else    
            return mid;
    }
    return -1;
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10

//二叉树的链表储存结构
struct TreeNode
{
    int data;
    //定义指向左节点和右节点的指针
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;







#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10

//先序中序后序递归遍历二叉树
//二叉树的链表储存结构
struct TreeNode
{
    int data;
    //定义指向左节点和右节点的指针
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//先序递归遍历二叉树
void PreOrderTraversal(BinTree BT)
{
    if (BT != NULL)
    {
        printf("%d ", BT->data);
        PreOrderTraversal(BT->left);
        PreOrderTraversal(BT->right);
    }
}

//中序遍历二叉树
void InOrderTraversal(BinTree BT)
{
    if (BT != NULL)
    {
        InOrderTraversal(BT->left);
        printf("%d ", BT->data);
        InOrderTraversal(BT->right);
    }
}

//后序遍历二叉树
void PostOderTraversal(BinTree BT)
{
    if (BT != NULL)
    {
        PostOderTraversal(BT->left);
        PostOderTraversal(BT->right);
        printf("%d ", BT->data); 
    }
}





#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#define Max_size 10

//利用堆栈先序中序非递归遍历二叉树

//二叉树的链表储存结构
struct TreeNode
{
    int data;
    //定义指向左节点和右节点的指针
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//创建堆栈数据类型
struct SNode
{
    int data;
    struct SNode *next;
};
typedef struct SNode *Stack;

//初始化堆栈
Stack CreateStack()
{
    Stack header = (Stack)malloc(sizeof(struct SNode));
    header->data = -1;
    header->next = NULL;
    return header;
}

//压栈
void Push(Stack S, int item)
{
    Stack pCurrent = (Stack)malloc(sizeof(struct SNode));
    pCurrent->data = item;
    pCurrent->next = S->next;
    S->next = pCurrent;
}

//出栈
int Pop(Stack S)
{
    Stack pCurrent;
    pCurrent = S->next;
    if (pCurrent == NULL)
    {
        printf("堆栈已空！\n");
        return NULL;
    }
    else
    {
        int item;
        item = pCurrent->data;
        S->next = pCurrent->next;
        free(pCurrent);
        return item;
    }
}

//利用堆栈实现先序遍历二叉树
void InOrderTraversal(BinTree BT)
{
    //创建二叉树辅助指针
    BinTree T = BT;
    //创建一个存二叉树数据的堆栈并初始化
    Stack S = CreateStack();
    //当二叉树节点和堆栈都不为空时
    while (T != NULL && S->next != NULL)
    {
        //如果二叉树节点左边不为空，那么就一直向左压栈
        while (T != NULL)
        {
            Push(S, T->data);
            T = T->left;
        }
        //如果二叉树节点左边为空，就让这个元素出栈，再指向右边
        if (S->next != NULL)
        {
            T = Pop(S);
            printf("%5d", T->data);
            T = T->right;
        }
    }
}

//利用堆栈实现中序遍历二叉树
void InOrderTraversal(BinTree BT)
{
    //创建二叉树辅助指针
    BinTree T = BT;
    //创建一个存二叉树数据的堆栈并初始化
    Stack S = CreateStack();
    //当二叉树节点和堆栈都不为空时
    while (T != NULL && S->next != NULL)
    {
        //如果二叉树节点左边不为空，那么就一直向左压栈
        while (T != NULL)
        {
            Push(S, T->data);
            printf("%5d", T->data);
            T = T->left;
        }
        //如果二叉树节点左边为空，就让这个元素出栈，再指向右边
        if (S->next != NULL)
        {
            T = Pop(S);
            T = T->right;
        }
    }
}



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//利用队列进行二叉树层序遍历

//创建二叉树结构类型
struct TreeNode
{
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//创建队列结构类型
struct Node
{
    int data;
    struct Node *next;
};

struct QNode
{
    struct Node *rear;
    struct Node *front;
};
typedef struct QNode *Queue;

//出队函数
int DeleteQ(Queue PtrQ)
{
    struct Node *front_cell;
    int front_item;
    if (PtrQ->front == NULL)
    {
        printf("队列已空！\n");
        return NULL;
    }
    front_cell = PtrQ->front;
    if (PtrQ->front == PtrQ->rear)
        PtrQ->front = PtrQ->rear = NULL;
    else
        PtrQ->front = PtrQ->front->next;
    front_item = front_cell->data;
    free(front_cell);
    return front_item;
}

//入队函数
void AddQ(Queue PtrQ, int item)
{
    struct Node *rear_cell;
    rear_cell = malloc(sizeof(struct Node));
    rear_cell->data = item;
    rear_cell->next = NULL;
    if (PtrQ->front == NULL)
    {
        PtrQ->front = rear_cell;
        PtrQ->rear = rear_cell;
        return;
    }
    else
    {
        PtrQ->rear->next = rear_cell;
        PtrQ->rear = rear_cell;
        return;
    }
}

//层序遍历二叉树函数
void LevelOrderTraversal(BinTree BT)
{
    //创建一个队列
    Queue Q;
    BinTree T = BT;
    int item;
    //如果是空树直接返回
    if (BT == NULL)
        return;
    //将树根存入队列
    AddQ(Q, T->data);
    //如果队列不空
    while (Q->front != NULL)
    {
        //输出队列首元素
        item = DeleteQ(Q);
        printf("%d ", item);
        //存入子节点
        if (T->left != NULL)
        {
            AddQ(Q, T->left->data);
            T = T->left;
        }
        if (T->right != NULL)
        {
            AddQ(Q, T->right->data);
            T = T->right;
        }
    }
}


#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//二叉搜索树的查找

//创建二叉树数据类型
struct TreeNode
{
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//二叉搜索树的递归查找函数
Position Find(int item, BinTree BST)
{
    //假如树根为空
    if (BST == NULL)
        return NULL;
    //如果待查找数大于树根元素，那么在右子树中查找
    if (item > BST->data)
        return Find(item, BST->right);
    //如果待查找数小于树根元素，那么在左子树中查找
    else if (item < BST->data)
        return Find(item, BST->left);
    //如果待查找数等于树根元素，那么返回树根
    else
        return BST;
}

//二叉搜索树的循环查找函数
Position WhileFind(int item, BinTree BST)
{
    while (BST != NULL)
    {
        if (item > BST->data)
            BST = BST->right;
        else if (item < BST->data)
            BST = BST->left;
        else
            return BST;
    }
    return NULL;
}

//二叉搜索树最小值的递归查找函数
Position FindMin(BinTree BST)
{
    //如果二叉搜索树为空
    if (BST == NULL)
        return NULL;
    //否则找到最左叶节点并返回
    if (BST->left == NULL)
        return BST;
    else
        return FindMin(BST->left);
}

//二叉搜索树最小值的循环查找函数
Position WhileFindMin(BinTree BST)
{
    if (BST == NULL)
        return NULL;
    while(BST->left != NULL)
        BST = BST->left;
    return BST;
}

//找最大值与前面同理，找最右节点就行了








#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//二叉搜索树的插入与删除

//创建二叉树数据类型
struct TreeNode
{
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
};
typedef struct TreeNode *BinTree;
typedef BinTree Position;

//二叉搜索树的递归查找函数
Position Find(int item, BinTree BST)
{
    //假如树根为空
    if (BST == NULL)
        return NULL;
    //如果待查找数大于树根元素，那么在右子树中查找
    if (item > BST->data)
        return Find(item, BST->right);
    //如果待查找数小于树根元素，那么在左子树中查找
    else if (item < BST->data)
        return Find(item, BST->left);
    //如果待查找数等于树根元素，那么返回树根
    else
        return BST;
}

//二叉搜索树的循环查找函数
Position WhileFind(int item, BinTree BST)
{
    while (BST != NULL)
    {
        if (item > BST->data)
            BST = BST->right;
        else if (item < BST->data)
            BST = BST->left;
        else
            return BST;
    }
    return NULL;
}

//二叉搜索树最小值的递归查找函数
Position FindMin(BinTree BST)
{
    //如果二叉搜索树为空
    if (BST == NULL)
        return NULL;
    //否则找到最左叶节点并返回
    if (BST->left == NULL)
        return BST;
    else
        return FindMin(BST->left);
}

//二叉搜索树最小值的循环查找函数
Position WhileFindMin(BinTree BST)
{
    if (BST == NULL)
        return NULL;
    while(BST->left != NULL)
        BST = BST->left;
    return BST;
}

//找最大值与前面同理，找最右节点就行了

//二叉搜素树的插入函数
BinTree Insert(int item, BinTree BST)
{
    //如果树根为空，那么生成并返回一个节点的二叉搜索树
    if (BST == NULL)
    {
        BST = (BinTree)malloc(sizeof(struct TreeNode));
        BST->data = item;
        BST->left = BST->right = NULL;
    }
    //找到要插入元素的位置
    else
    {
        //如果待删除元素小于树根元素，那么在左子树中查找
        if (item < BST->data)
            //递归插入左子树
            BST->left = Insert(item, BST->left);
        //否则在右子树中查找
        else if (item > BST->data)
            BST->right = Insert(item, BST->right);
    }
    return BST;
}

//二叉搜素树的删除函数
BinTree Delete(int item, BinTree BST)
{
    Position Tmp;
    //当没找到要删除的元素时
    if (BST == NULL)
        printf("要删除的元素未找到！\n");
    //如果要删除的元素小于树根元素
    else if (item < BST->data)
        //左子树递归删除
        BST->left = Delete(item, BST->left);
    //如果大于树根元素
    else if (item > BST->right)
        //右子树递归删除
        BST->right = Delete(item, BST->right);
    //找到了要删除的节点
    else
    {
        //如果要删除结点有两个子树
        if (BST->left != NULL && BST->right != NULL)
        {
            //在删除节点的右子树中找到最小元素填充删除节点
            Tmp = FindMin(BST->right);
            BST->data = Tmp->data;
            //删除右子树中最小节点
            BST->right = Delete(BST->data, BST->right);
        }
        //如果被删除节点只有一个子树或没有子树
        else
        {
            Tmp = BST;
            //有右子树或无节点
            if (BST->left == NULL)
                BST = BST->right;
            //有左子树或无节点
            else if (BST->right == NULL)
                BST = BST->left;
            //释放内存
            free(Tmp);
        }
    }
    return BST;
}




#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

//AVL树的旋转与插入

//创建AVL树数据类型
struct AVLNode
{
    int data;
    struct AVLNode *left;
    struct AVLNode *right;
    int height;
};
typedef struct AVLNode *AVLTree;
typedef AVLTree Position;

int Max(int a, int b)
{
    return a > b ? a : b;
}

GetHeight(AVLTree A);

//LL单旋函数
AVLTree SingleLeftRotation(AVLTree A)
{
    //注意：A必须有一个左子结点B
    //将A与B做左单旋，更新A与B的高度，返回新的根结点B
    AVLTree B = A->left;
    //将B的右子树放在A的左子树上
    A->left = B->right;
    //将A放在B的右子树上
    B->right = A;
    //更新A与B的高度
    A->height = Max(GetHeight(A->left), GetHeight(A->right)) + 1;
    B->height = Max(GetHeight(B->left), A->height) + 1;
    return B;
}

//RR单旋函数
AVLTree SingleRightRotation(AVLTree A)
{
    //注意：A必须有一个右子结点B
    //将A与B做右单旋，更新A与B的高度，返回新的根结点B
    AVLTree B = A->right;
    //把B的左子树放在A的右子树上
    A->right = B->left;
    //把A放在B的左子树上
    B->left = A;
    //更新A与B的高度
    A->height = Max(GetHeight(A->left), GetHeight(A->right)) + 1;
    B->height = Max(GetHeight(B->right), A->height) + 1;
    return B;
}

//LR双旋函数
AVLTree DoubleLeftRightRotation(AVLTree A)
{
    //注意：A必须有一个左子结点B，且B必须有一个右子结点C
    //将A、B与C做两次单旋，返回新的根结点C

    //将B与C做右单旋，C被返回
    A->left = SingleRightRotation(A->left);
    //将A与C做左单旋，C被返回
    A = SingleLeftRotation(A);
    return A;
}

//RL双旋函数
AVLTree DoubleRightLeftRotation(AVLTree A)
{
    //注意：A必须有一个右子结点B，且B必须有一个左子结点C
    //将A、B与C做两次单旋，返回新的根结点C

    //将B与C做左单旋，C被返回
    A->right = SingleLeftRotation(A->right);
    //将A与C做右单旋，C被返回
    A = SingleRightRotation(A);
    return A;
}

//二叉平衡树的插入函数
AVLTree Insert(AVLTree T, int item)
{
    //将X插入AVL树T中，并且返回调整后的AVL树

    //如果该树为空树
    if (T == NULL)
    {
        //新建一个节点
        T = (AVLTree)malloc(sizeof(struct AVLNode));
        T->data = item;
        T->height = 0;
        T->left = T->right = NULL;
    }
    //如果item比树根元素小
    if (item < T->data)
    {
        //插入T的左子树
        T->left = Insert(T->left, item);
        //如果需要左旋
        if (GetHeight(T->left) - GetHeight(T->right) == 2)
            //如果item小于左子树的元素
            if (item < T->left->data)
                //左单旋
                T = SingleLeftRotation(T);
            //否则左右双旋
            else
                T = DoubleLeftRightRotation(T);
    }
    //如果比树根元素大，那么和上面类型
    else if (item > T->right)
    {
        T->right = Insert(T->right, item);
        if (GetHeight(T->right) - GetHeight(T->left) == 2)
            if (item > T->right->data)
                T = SingleRightRotation(T);
            else
                T = DoubleRightLeftRotation(T);
    }

    //每次递归更新树高
    T->height = Max(GetHeight(T->left), GetHeight(T->right)) + 1;

    return T;
}


//二叉树的一些操作



//输出二叉树的所有叶结点
//与遍历二叉树所有结点相比，只需加一个判断条件即可
void PreorderPrintLeaves(BinTree BT)
{
    if(BT)
    {
        if(!BT->Left && !BT->Right) //如果左子树和右子树都为空，那么他是叶结点
        {
            printf("%d", BT->Data);
        }
        PreorderPrintLeaves(BT->Left);
        PreorderPrintLeaves(BT->Right);
    }
}

//求二叉树的高度
//树的高度是左右子树两种中最大值加一
//可利用后序遍历递归算出高度
int GetHeight(BinTree BT)
{
    int HL, HR, MaxH;

    if(BT)
    {
        HL = GetHeight(BT->Left);   //求左子树高度
        HR = GetHeight(BT->Right);  //求右子树高度
        MaxH = HL > HR ? HL : HR;
        return (MaxH + 1);
    }
    else
        return 0;   //空树高度为0
}

//层序生成二叉树
//和层序遍历二叉树一样，需先创建一个队列，然后用队列操作
#define NoInfo 0    //用0表示没有结点

BinTree CreatBinTree()
{
    int Data;
    BinTree BT, T;
    Queue Q = CreatQueue(); //创建空队列

    //建立根节点
    scanf("%d", &Data);
    if(Data != NoInfo)
    {
        //分配根节点单元，将节点地址入队
        BT = (BinTree)malloc(sizeof(struct TNode));
        BT->Data = Data;
        BT->Left = NULL;
        BT->Right = NULL;
        AddQ(Q, BT);
    }
    else    //若第一个数据是0，则返回空树
        return NULL;
    while(!IsEmpty(Q))
    {
        T = DeleteQ(Q); //取出一个结点

        scanf("%d", &Data); //读入T的左孩子
        if(Data == NoInfo)
            T->Left = NULL;
        else
        {
            //分配新节点为出队结点左孩子，新节点入队
            T->Left = (BinTree)malloc(sizeof(struct TNode));
            T->Left->Data = Data;
            T->Left->Left = T->Left->Right = NULL;
            AddQ(T->Left);
        }

        scanf("%d", &Data);//读入T的右孩子
        if(Data == NoInfo)
            T->Right = NULL;
        else
        {
            //分配新节点为出队结点左孩子，新节点入队
            T->Right = (BinTree)malloc(sizeof(struct TNode));
            T->Right->Data = Data;
            T->Right->Left = T->Right->Right = NULL;
            AddQ(T->Right);
        }
    }
    return BT;
}

//堆的结构
struct HNode
{
    ElementType *Data;	//存储元素的数组
    int Size;			//堆当前元素个数
    int Capacity;		//堆的最大容量
};
typedef struct HNode *Heap;	//堆结构的定义
typedef Heap Max_Heap;	//最大堆
typedef Heap Min_Heap;	//最小堆

#define MAX_DATA 1000	//此值应该根据具体情况定义为大于堆中所有可能元素的值

//创建容量为Max_Size的空的最大堆
Max_Heap Create_Heap(int Max_Size)
{
    Max_Heap H = (Max_Heap)malloc(sizeof(struct HNode));
    H->Data = (ElementType *)malloc((Max_Size + 1) * sizeof(ElementType));
    H->Size = 0;
    H->Capacity = Max_Size;
    H->Data[0] = MAX_DATA;	//定义“哨兵”为大于堆中所有可能元素的值
    
    return H;
}

//判断最大堆是否已满
bool Is_Full(Max_Heap H)
{
    return (H->Size == H->Capacity);
}

//最大堆的插入
bool Insert(Max_Heap H, ElementType X)
{
    int i;
    
    if(Is_Full(H))
    {
        printf("最大堆已满\n");
        return false;
    }
    i = H->Size + 1;	//i指向插入后堆中最后一个元素的位置
    for( ; H->Data[i / 2] < X; i /= 2)
        H->Data[i] = H->Data[i / 2];	//上滤X
    H->Data[i] = X;		//将X插入
    
    return true;
}

//判断最大堆是否为空
bool Is_Empty(Max_Heap H)
{
    return (H->Size == 0);
}

#define ERROR -1	//错误标识应定义为堆中不可能出现的元素

//取出键值最大的元素，并删除一个结点
ElementType Delete_Max(Max_Heap H)
{
    int Parent, Child;
    ElementType Max_Item, X;
    
    if(Is_Empty(H))
    {
        printf("最大堆已空\n");
        return ERROR;
    }
    
    Max_Item = H->Data[1];	//取出根节点存放的最大值
    //用最大堆最后一个元素放在根节点，然后下滤结点
    X = H->Data[H->Size];
    H->Size--;	//规模要减少
    for(Parent = 1; Parent * 2 <= H->Size; Parent = Child)
    {
        Child = Parent * 2;
        if((Child != H->Size) && (H->Data[Child] < H->Data[Child + 1]))	
            Child++;	//Child指向左右子树的较大者
        if(X >= H->Data[Child])
           break;	//找到了合适位置
        else	//下滤
            H->Data[Parent] = H->Data[Child];
    }
    H->Data[Parent] = X;
    
    return Max_Item;
}

//最大堆的建立
//第一步：将N个元素按顺序存入二叉树中，这一步只要求满足完全二叉树的特性，不管它是否有序
//第二步：调整各节点元素，以满足最大堆特性
//这种方法比一个一个插入元素高效
void Perc_Down(Max_Heap H, int p)
{
    //下滤：将H中以H->Data[p]为根的子堆调整为最大堆
    int Parent, Child;
    ElementType X;
    
    X = H->Data[p];	//取出根节点存放的值
    for(Parent = p; Parent * 2 <= H->Size; Parent = Child)
    {
        Child = Parent * 2;
        if((Child != H->Size) && (H->Data[Child] < H->Data[Child + 1]))
            Child++;
        if(X > H->Data[Parent])
            break;
        else
            H->Data[Parent] = H->Data[Child];
    }
    H->Data[Parent] = X;
}

void Build_Heap(Max_Heap H)
{
    //调整堆中的元素，使其满足最大堆特性
    //这里假设所有元素已存入堆中
    
    int i;
    
    for(i = H->Size / 2; i > 0; i--)
    {
        //从最后一个结点的父结点开始，到根节点1
        Perc_Down(H, i);
    }
}